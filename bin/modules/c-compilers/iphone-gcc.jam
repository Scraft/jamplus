C.AR			?= ar ru ;
C.CC			?= gcc ;
C.C++			?= g++ ;
C.LINK			?= g++ ;
C.RANLIB		?= ranlib ;
C.STRIP			?= strip ;

SUFMODULE	= .dylib ;

actions C.Link
{
	"$(C.LINK)" $(LINKFLAGS) -o $(<[1]:C) $(>:C) $(NEEDLIBS:TC) $(LINKLIBS:T)
}


rule C.LinkFrameworks TARGET : FRAMEWORKS : THE_CONFIG : THE_PLATFORM
{
	C.LinkFlags $(TARGET) : "-framework $(FRAMEWORKS)" : $(THE_CONFIG) : $(THE_PLATFORM) ;
}

rule C.WeakLinkFrameworks TARGET : FRAMEWORKS : THE_CONFIG : THE_PLATFORM
{
	C.LinkFlags $(TARGET) : "-weak_framework $(FRAMEWORKS)" : $(THE_CONFIG) : $(THE_PLATFORM) ;
}

# Only want to apply wild card rules from C.MacOSX_SDK once...
C.MacOSX_SDK.CalledYet = false ;

rule C.MacOSX_SDK TARGET : SDK_PLATFORM : SDK_VERSION : SDK_VERSION_MIN {
	if ! ( $(PLATFORM) in macosx32 macosx64 iphonesimulator iphone ipadsimulator ipad ) { return ; }

	if $(SDK_PLATFORM) in macosx32 macosx64 {
		SDK_PLATFORM = macosx ;
	}

	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local developerRoot ;
	local isysroot ;
	local flags ;
	local c++flags ;
	local ldflags ;
	local defaultversionmin ;
	switch $(SDK_PLATFORM) {
		case macosx :
			developerRoot = /Developer/SDKs ;
			C.STRIP = /Developer/usr/bin/strip ;
			SDK_VERSION ?= 10.5 ;
			switch $(SDK_VERSION) {
				case 10.4 :
					C.CC	= gcc-4.0 ;
					C.C++	= g++-4.0 ;
					C.LINK	= g++-4.0 ;
					isysroot = $(developerRoot)/MacOSX10.4u.sdk ;
					defaultversionmin = 10.4 ;
					XCODE_SDKROOT = macosx10.4 ;

				case 10.4u :
					C.CC	= gcc-4.0 ;
					C.C++	= g++-4.0 ;
					C.LINK	= g++-4.0 ;
					isysroot = $(developerRoot)/MacOSX10.4u.sdk ;
					defaultversionmin = 10.4 ;
					XCODE_SDKROOT = macosx10.4 ;

				case 10.5 :
					C.CC	= gcc ;
					C.C++	= g++ ;
					C.LINK	= g++ ;
					isysroot = $(developerRoot)/MacOSX10.5.sdk ;
					defaultversionmin = 10.5 ;
					XCODE_SDKROOT = macosx10.5 ;

				case 10.6 :
					C.CC	= gcc ;
					C.C++	= g++ ;
					C.LINK	= g++ ;
					isysroot = $(developerRoot)/MacOSX10.6.sdk ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = macosx10.6 ;
				
				case * :		Exit "* MacOSX_SDK: Unsupported version $(SDK_VERSION) for SDK platform $(SDK_PLATFORM)." ;
			}
			SDK_VERSION_MIN ?= $(defaultversionmin) ;
			flags += -mmacosx-version-min=$(SDK_VERSION_MIN) ;
			developerRoot = $(isysroot) ;

		case iphone :
			developerRoot = /Developer/Platforms/iPhoneOS.platform/Developer ;
			C.STRIP = /Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/strip ;
			SDK_VERSION ?= 5.0 ;
			switch $(SDK_VERSION) {
				case 2.0 :
					isysroot = $(developerRoot)/SDKs/iPhoneOS2.0.sdk ;
					XCODE_SDKROOT = iphoneos2.0 ;

				case 2.1 :
					isysroot = $(developerRoot)/SDKs/iPhoneOS2.1.sdk ;
					XCODE_SDKROOT = iphoneos2.1 ;

				case 2.2 :
					isysroot = $(developerRoot)/SDKs/iPhoneOS2.2.sdk ;
					XCODE_SDKROOT = iphoneos2.2 ;

				case 3.0 :
					isysroot = $(developerRoot)/SDKs/iPhoneOS3.0.sdk ;
					XCODE_SDKROOT = iphoneos3.0 ;

				case 3.1 :
					isysroot = $(developerRoot)/SDKs/iPhoneOS3.1.sdk ;
					XCODE_SDKROOT = iphoneos3.1 ;

				case 3.1.2 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneOS3.1.2.sdk ;
					flags += -arch armv6 -mno-thumb ;
					XCODE_SDKROOT = iphoneos3.1.2 ;
					SDK_VERSION_MIN ?= 3.1.2 ;

				case 3.1.3 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneOS3.1.3.sdk ;
					flags += -arch armv6 -mno-thumb ;
					XCODE_SDKROOT = iphoneos3.1.3 ;
					SDK_VERSION_MIN ?= 3.1.3 ;

				case 3.2 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneOS3.2.sdk ;
					flags += -arch armv6 -mno-thumb ;
					XCODE_SDKROOT = iphoneos3.2 ;
					SDK_VERSION_MIN ?= 3.2 ;

				case 4.0 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneOS4.0.sdk ;
					flags += -arch armv6 -mno-thumb ;
					XCODE_SDKROOT = iphoneos4.0 ;
					SDK_VERSION_MIN ?= 4.0 ;

				case 4.1 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneOS4.1.sdk ;
					flags += -arch armv6 -mno-thumb ;
					XCODE_SDKROOT = iphoneos4.1 ;
					SDK_VERSION_MIN ?= 4.1 ;

				case 4.2 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneOS4.2.sdk ;
					flags += -arch armv6 -mno-thumb ;
					XCODE_SDKROOT = iphoneos4.2 ;
					SDK_VERSION_MIN ?= 4.2 ;

				case 4.3 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneOS4.3.sdk ;
					flags += -arch armv6 -mno-thumb ;
					XCODE_SDKROOT = iphoneos4.3 ;
					SDK_VERSION_MIN ?= 4.3 ;

				case 5.0 :
					CC	= $(developerRoot)/usr/bin/gcc ;
					C++	= $(developerRoot)/usr/bin/g++ ;
					LINK	= $(developerRoot)/usr/bin/g++ ;
					isysroot = $(developerRoot)/SDKs/iPhoneOS5.0.sdk ;
					flags += -arch armv6 -miphoneos-version-min=5.0 ; 
					XCODE_SDKROOT = iphoneos5.0 ;

				case * :		Exit "* MacOSX_SDK: Unsupported version $(SDK_VERSION) for SDK platform $(SDK_PLATFORM)." ;
			}
			SDK_VERSION_MIN ?= $(SDK_VERSION) ;
			flags += -miphoneos-version-min=$(SDK_VERSION_MIN) ;

		case iphonesimulator :
			developerRoot = /Developer/Platforms/iPhoneSimulator.platform/Developer ;
			C.STRIP = /Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/strip ;
			SDK_VERSION ?= 5.0 ;
			switch $(SDK_VERSION) {
				case 2.0 :
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator2.0.sdk ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos2.0 ;
					
				case 2.1 :
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator2.1.sdk ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos2.1 ;

				case 2.2 :
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator2.2.sdk ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos2.2 ;

				case 3.0 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator3.0.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30000 ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos3.0 ;

				case 3.1 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator3.1.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30000 ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos3.1 ;

				case 3.1.2 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator3.1.2.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30000 ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos3.1.2 ;

				case 3.1.3 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator3.1.3.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30000 ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos3.1.3 ;

				case 3.2 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator3.2.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30200 ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos3.2 ;

				case 4.0 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator4.0.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30200 ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos4.0 ;

				case 4.1 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator4.1.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30200 ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos4.1 ;

				case 4.2 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator4.2.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30200 ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos4.2 ;

				case 4.3 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator4.3.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30200 ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos4.3 ;

				case 5.0 :
					CC	= $(developerRoot)/usr/bin/gcc ;
					C++	= $(developerRoot)/usr/bin/g++ ;
					LINK	= $(developerRoot)/usr/bin/g++ ;
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator5.0.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=50000 -arch i386 ;
					XCODE_SDKROOT = iphoneos5.0 ;

				case * :		Exit "* MacOSX_SDK: Unsupported version $(SDK_VERSION) for SDK platform $(SDK_PLATFORM)." ;
			}
			SDK_VERSION_MIN ?= $(defaultversionmin) ;
			flags += -arch i386 -mmacosx-version-min=$(SDK_VERSION_MIN) ;

		case ipadsimulator :
			developerRoot = /Developer/Platforms/iPhoneSimulator.platform/Developer ;
			C.STRIP = /Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/strip ;
			SDK_VERSION ?= 5.0 ;
			SDK_VERSION_MIN ?= 5.0 ;
			switch $(SDK_VERSION) {
				case 3.2 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator3.2.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30200 -arch i386 ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos3.2 ;

				case 4.0 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator4.0.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30200 -arch i386 ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos4.0 ;

				case 4.2 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator4.2.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30200 -arch i386 ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos4.2 ;

				case 4.3 :
					C.CC	= $(developerRoot)/usr/bin/llvm-gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/llvm-g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/llvm-g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator4.3.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=40300 -arch i386 ;
					defaultversionmin = 10.6 ;
					XCODE_SDKROOT = iphoneos4.3 ;

				case 5.0 :
					CC	= $(developerRoot)/usr/bin/gcc ;
					C++	= $(developerRoot)/usr/bin/g++ ;
					LINK	= $(developerRoot)/usr/bin/g++ ;
					isysroot = $(developerRoot)/SDKs/iPhoneSimulator5.0.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=50000 -arch i386 ;
					XCODE_SDKROOT = iphoneos5.0 ;

				case * :		Exit "* MacOSX_SDK: Unsupported version $(SDK_VERSION) for SDK platform $(SDK_PLATFORM)." ;
			}
			SDK_VERSION_MIN ?= $(defaultversionmin) ;
		#	flags += -mmacosx-version-min=$(SDK_VERSION_MIN) ;

		case ipad :
			developerRoot = /Developer/Platforms/iPhoneOS.platform/Developer ;
			C.STRIP = /Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/strip ;
			SDK_VERSION ?= 5.0 ;
			SDK_VERSION_MIN ?= 5.0 ;
			switch $(SDK_VERSION) {
				case 3.2 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneOS3.2.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30200 -arch armv7 -mno-thumb ; 
					XCODE_SDKROOT = iphoneos3.2 ;

				case 4.0 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneOS4.0.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30200 -arch armv7 -mno-thumb ; 
					XCODE_SDKROOT = iphoneos4.0 ;

				case 4.2 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneOS4.2.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30200 -arch armv7 -mno-thumb ; 
					XCODE_SDKROOT = iphoneos4.2 ;

				case 4.3 :
					C.CC	= $(developerRoot)/usr/bin/gcc-4.2 ;
					C.C++	= $(developerRoot)/usr/bin/g++-4.2 ;
					C.LINK	= $(developerRoot)/usr/bin/g++-4.2 ;
					isysroot = $(developerRoot)/SDKs/iPhoneOS4.3.sdk ;
					flags += -D__IPHONE_OS_VERSION_MIN_REQUIRED=30200 -arch armv7 -mno-thumb ; 
					XCODE_SDKROOT = iphoneos4.3 ;
					DT_COMPILER = 4.2 ;
					DT_PLATFORM_BUILD = 8F190 ;
					DT_PLATFORM_VERSION = 4.3 ;
					DT_SDK_BUILD = 8F190 ;
					DT_XCODE = 0400 ;
					DT_XCODE_BUILD = 10M2518 ;

				case 5.0 :
					CC	= $(developerRoot)/usr/bin/gcc ;
					C++	= $(developerRoot)/usr/bin/g++ ;
					LINK	= $(developerRoot)/usr/bin/g++ ;
					isysroot = $(developerRoot)/SDKs/iPhoneOS5.0.sdk ;
					flags += -arch armv7 ; 
					XCODE_SDKROOT = iphoneos5.0 ;

				case * :		Exit "* MacOSX_SDK: Unsupported version $(SDK_VERSION) for SDK platform $(SDK_PLATFORM)." ;
			}
			SDK_VERSION_MIN ?= $(SDK_VERSION) ;
			flags += -miphoneos-version-min=$(SDK_VERSION_MIN) ;
	}

	ISYSROOT on $(TARGET) = $(isysroot) ;	
	IPHONEOS_SDK_VERSION = $(SDK_VERSION) ;
	IOS_SDK_VERSION_MIN = $(SDK_VERSION_MIN) ;

	flags += -fmessage-length=0 -pipe ;
	flags += -fvisibility=hidden -gdwarf-2 ;
	c++flags = "" ;
	c++flags += -fvisibility-inlines-hidden ;
	ldflags = "" ;
	ldflags += -dead_strip -all_load -ObjC ;

	if $(C.MacOSX_SDK.CalledYet) = false
	{
		C.MacOSX_SDK.CalledYet = true ;

	C.Flags CC	: * : -isysroot $(isysroot) $(flags) : : $(PLATFORM) ;
		C.Flags C++	: * : -isysroot $(isysroot) $(flags) $(c++flags) : : $(PLATFORM) ;
	C.Flags M	: * : -isysroot $(isysroot) $(flags) -fobjc-abi-version=2 -fobjc-legacy-dispatch : : $(PLATFORM) ;
	C.Flags MM	: * : -isysroot $(isysroot) $(flags) -fobjc-abi-version=2 -fobjc-legacy-dispatch : : $(PLATFORM) ;
		C.LinkFlags * : -isysroot $(isysroot) $(flags) $(ldflags) : : $(PLATFORM) ;
	}

	if $(TARGETINFO_LOCATE) {
		Contents += "Projects[ [[$(TARGET)]] ].XCODE_SDKROOT[ [[$(PLATFORM)]] ][ [[$(CONFIG)]] ] = [[$(XCODE_SDKROOT)]]

" ;
	}
}


rule C._BundleInfoArray KEY : VALUE {
	INFO_PLIST on $(TARGET) += "$(TAB)<key>$(KEY)</key>$(NEWLINE)$(TAB)<array>$(NEWLINE)" ;
	for value in $(VALUE) {
		INFO_PLIST on $(TARGET) += "$(TAB)$(TAB)<string>$(value)</string>$(NEWLINE)" ;
	}
	INFO_PLIST on $(TARGET) += "$(TAB)</array>$(NEWLINE)" ;
}


rule C._BundleInfoBoolean KEY : VALUE {
	INFO_PLIST on $(TARGET) += "$(TAB)<key>$(KEY)</key>$(NEWLINE)$(TAB)" ;
	if $(VALUE) = true {
		INFO_PLIST on $(TARGET) += "<true/>$(NEWLINE)" ;
	} else {
		INFO_PLIST on $(TARGET) += "<false/>$(NEWLINE)" ;
	}
}


rule C._BundleInfoString KEY : VALUE {
	INFO_PLIST on $(TARGET) += "$(TAB)<key>$(KEY)</key>$(NEWLINE)$(TAB)<string>$(VALUE)</string>$(NEWLINE)" ;
}


rule C.BundleInfo TARGET : TYPE : VALUE {
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	on $(TARGET) if ! $(INFO_PLIST) {
		INFO_PLIST on $(TARGET) ?= "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">
<plist version=\"1.0\">
<dict>
" ;

		C._BundleInfoString CFBundleDevelopmentRegion : en ;
		C._BundleInfoString CFBundleExecutable : [ C._retrieveOutputName $(TARGET) ] ;
		C._BundleInfoString CFBundleInfoDictionaryVersion : 6.0 ;
		C._BundleInfoString CFBundlePackageType : APPL ;
		C._BundleInfoString CFBundleSignature : ???? ;
		C._BundleInfoString CFBundleResourceSpecification : ResourceRules.plist ;

		switch $(PLATFORM) {
			case macosx32 :			VALUE = "" ;
			case macosx64 :			VALUE = "" ;
			case iphone :
				C._BundleInfoBoolean LSRequiresIPhoneOS : true ;
#				C._BundleInfoArray UIDeviceFamily : 1 ;
				C._BundleInfoString DTPlatformName : iphoneos ;
				C._BundleInfoString DTSDKName : iphoneos$(IPHONEOS_SDK_VERSION) ;
				C._BundleInfoArray CFBundleSupportedPlatforms : iPhoneOS ;
				C._BundleInfoString MinimumOSVersion : $(IOS_SDK_VERSION_MIN) ;

			case iphonesimulator :
				C._BundleInfoBoolean LSRequiresIPhoneOS : true ;
#				C._BundleInfoArray UIDeviceFamily : 1 ;
				C._BundleInfoString DTPlatformName : iphonesimulator ;
				C._BundleInfoString DTSDKName : iphonesimulator$(IPHONEOS_SDK_VERSION) ;
				C._BundleInfoArray CFBundleSupportedPlatforms : iPhoneSimulator ;
				C._BundleInfoString MinimumOSVersion : $(IOS_SDK_VERSION_MIN) ;

			case ipad :
				C._BundleInfoBoolean LSRequiresIPhoneOS : true ;
				C._BundleInfoArray UIDeviceFamily : 2 ;
				C._BundleInfoString DTPlatformName : iphoneos ;
				C._BundleInfoString DTSDKName : iphoneos$(IPHONEOS_SDK_VERSION) ;
				C._BundleInfoArray CFBundleSupportedPlatforms : iPhoneOS ;
				C._BundleInfoString MinimumOSVersion : $(IOS_SDK_VERSION_MIN) ;

			case ipadsimulator :
				C._BundleInfoBoolean LSRequiresIPhoneOS : true ;
				C._BundleInfoArray UIDeviceFamily : 2 ;
				C._BundleInfoString DTPlatformName : iphonesimulator ;
				C._BundleInfoString DTSDKName : iphonesimulator$(IPHONEOS_SDK_VERSION) ;
				C._BundleInfoArray CFBundleSupportedPlatforms : iPhoneSimulator ;
				C._BundleInfoString MinimumOSVersion : $(IOS_SDK_VERSION_MIN) ;
		}
	}

	# This stuff seems to be required for submitting with 4.3 of the SDK at least (on IPad).
	if $(DT_COMPILER) && $(DT_COMPILER) != "" {
		C._BundleInfoString DTCompiler : $(DT_COMPILER) ;
	}
	if $(DT_PLATFORM_BUILD) && $(DT_PLATFORM_BUILD) != "" {
		C._BundleInfoString DTPlatformBuild : $(DT_PLATFORM_BUILD) ;
	}
	if $(DT_PLATFORM_VERSION) && $(DT_PLATFORM_VERSION) != "" {
		C._BundleInfoString DTPlatformVersion : $(DT_PLATFORM_VERSION) ;
	}
	if $(DT_SDK_BUILD) && $(DT_SDK_BUILD) != "" {
		C._BundleInfoString DTSDKBuild : $(DT_SDK_BUILD) ;
	}
	if $(DT_XCODE) && $(DT_XCODE) != "" {
		C._BundleInfoString DTXcode : $(DT_XCODE) ;
	}
	if $(DT_XCODE_BUILD) && $(DT_XCODE_BUILD) != "" {
		C._BundleInfoString DTXcodeBuild : $(DT_XCODE_BUILD) ;
	}

	switch $(TYPE:L) {
		case info :					C._BundleInfoString CFBundleGetInfoString : $(VALUE) ;
		case iconfile :				C._BundleInfoString CFBundleIconFile : $(VALUE) ;
		case iconfiles :			C._BundleInfoArray CFBundleIconFiles : $(VALUE) ;
		case longversion :			C._BundleInfoString CFBundleLongVersionString : $(VALUE) ;
		case bundlename :
			C._BundleInfoString CFBundleName : $(VALUE) ;
			CFBundleName on $(TARGET) = $(VALUE) ;
		case displayname :
			C._BundleInfoString CFBundleDisplayName : $(VALUE) ;
			CFBundleDisplayName on $(TARGET) = $(VALUE) ;
		case executable :			C._BundleInfoString CFBundleExecutable : $(VALUE) ;
		case identifier :
			C._BundleInfoString CFBundleIdentifier : $(VALUE[1]) ;
			CFBundleIdentifier on $(TARGET) = $(VALUE[1]) ;
			AppIdentifierPrefix on $(TARGET) = $(VALUE[2]) ;
		case shortversion :			C._BundleInfoString CFShortVersionString : $(VALUE) ;
		case bundleversion :
			C._BundleInfoString CFBundleVersion : $(VALUE) ;
			CFBundleVersion = $(VALUE) ;
		case copyright :			C._BundleInfoString NSHumanReadableCopyright : $(VALUE) ;
		case mainnibfile :			C._BundleInfoString NSMainNibFile : $(VALUE) ;
		case resourcespec :			C._BundleInfoString CFBundleResourceSpecification : $(VALUE) ;
		case supportedplatforms :   C._BundleInfoArray CFBundleSupportedPlatforms : $(VALUE) ;
		case minimumosversion :		C._BundleInfoString MinimumOSVersion : $(VALUE) ;
		case uidevicefamily :		C._BundleInfoArray UIDeviceFamily : $(VALUE) ;
		case uiprerenderedicon :	C._BundleInfoBoolean UIPrerenderedIcon : $(VALUE) ;
		case uistatusbarhidden :	C._BundleInfoBoolean UIStatusBarHidden : $(VALUE) ;
		case uiinterfaceorientation :	
			if $(VALUE) = portrait {
				C._BundleInfoString UIInterfaceOrientation : UIInterfaceOrientationPortrait ;
			}
			if $(VALUE) = portraitupsidedown {
				C._BundleInfoString UIInterfaceOrientation : UIInterfaceOrientationPortraitUpsideDown ;
			}
			if $(VALUE) = landscapeleft {
				C._BundleInfoString UIInterfaceOrientation : UIInterfaceOrientationLandscapeLeft ;
			}
			if $(VALUE) = landscaperight {
				C._BundleInfoString UIInterfaceOrientation : UIInterfaceOrientationLandscapeRight ;
			}
		case uisupportedinterfaceorientations :
			local values = ;
			if portrait in $(VALUE) {
				values += UIInterfaceOrientationPortrait ;
			}
			if portraitupsidedown in $(VALUE) {
				values += UIInterfaceOrientationPortraitUpsideDown ;
			}
			if landscapeleft in $(VALUE) {
				values += UIInterfaceOrientationLandscapeLeft ;
			}
			if landscaperight in $(VALUE) {
				values += UIInterfaceOrientationLandscapeRight ;
			}
			C._BundleInfoArray UISupportedInterfaceOrientations : $(values) ;
	}
}

actions C.Strip
{
	$(C.STRIP) $(2:CT) -o $(1:CT)
}

rule C._ApplicationFromObjects_LinkFlags
{
	if bundle in $(OPTIONS) {
		local outputName = [ C._retrieveOutputName $(TARGET) ] ;
		local bundlePath = $(outputPath)/$(outputName).app ;
		BUNDLE_PATH on $(TARGET) = $(bundlePath) ;
		bundleExe = [ C.TargetGrist $(TARGET)|bundle : $(_linkTargets) ] ;
		MakeLocate $(bundleExe) : $(bundlePath) ;
		Depends $(TARGET) : $(bundleExe) ;
		BUNDLE_EXE on $(TARGET) = $(bundleExe) ;

		local bundleTarget = $(TARGET):bundle ;
		local cleanBundleTarget = clean:$(bundleTarget) ;
		BUNDLE_TARGET on $(TARGET) = $(bundleTarget) ;
		CLEAN_BUNDLE_TARGET on $(TARGET) = $(cleanBundleTarget) ;
		Depends $(TARGET) : $(bundleTarget) ;
		NotFile $(bundleTarget) ;
		Depends clean:$(TARGET) : $(cleanBundleTarget) ;
		NotFile $(cleanBundleTarget) ;
		Always $(cleanBundleTarget) ;
	}
}


actions C._GenerateDSYMFile
{
	/Developer/usr/bin/dsymutil $(2:C) -o $(OUTPUT_PATH:C)
}


rule C.GenerateDSYMFile TARGET
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	local bundlePath ;
	local _t ;
	on $(TARGET) {
		_t = $(LINK_TARGET) ;
		bundlePath = $(BUNDLE_PATH) ;
	}
	local dsymBundlePath = $(bundlePath).dSYM ;
	local _t.dsym = $(_t).DSYM ;
	BINDING on $(_t) = $(_t:BS) ;
	BINDING on $(_t.dsym) = $(_t:BS) ;
	OUTPUT_PATH on $(_t.dsym) = $(dsymBundlePath) ;
	MakeLocate $(_t.dsym) : $(dsymBundlePath)/Contents/Resources/DWARF ;
	Depends $(TARGET) : $(_t.dsym) : $(_t) ;
	Clean clean:$(TARGET) : $(_t.dsym) ;
	C._GenerateDSYMFile $(_t.dsym) : $(_t) ;
}


actions CpResource
{
	/Developer/Library/PrivateFrameworks/DevToolsCore.framework/Resources/pbxcp -exclude .DS_Store -exclude CVS -exclude .svn -exclude .git -strip-debug-symbols -resolve-src-symlinks $(2) $(1:D)
}

C.__DOLLAR = \\$ ;

actions ProcessEntitlements
{
	cp $(2) $(1)
	sed -i "" -e "s/$(C.__DOLLAR)(CFBundleIdentifier)/$(CFBundleIdentifier:E=*needs-CFBundleIdenfier*)/g" -e "s/$(C.__DOLLAR)(AppIdentifierPrefix)/$(AppIdentifierPrefix:E=*needs-AppIdentifierPrefix*)./g" -e "s/<key>keychain-access-groups/$(GET_TASK_ALLOW:E="")<key>keychain-access-groups/g" $(1)
}

rule C.SetTaskAllow TARGET : VALUE
{
	# If true/false isn't specific, assume true, as 'setting' could be thought of enabling.
	VALUE ?= true ;

	# Save value passed, we'll later check both C.$(TARGET) and C.* so we can have config defaults and support overrides.
	C.$(TARGET).GET_TASK_ALLOW = $(VALUE) ;
}

rule C._ApplicationFromObjects_PostBuild
{
	if bundle in $(OPTIONS) {
		local bundlePath ;
		local bundleTarget ;
		local cleanBundleTarget ;
		local isysroot ;
		local getTaskAllowValue ;
		on $(TARGET) {
			bundlePath = $(BUNDLE_PATH) ;
			bundleTarget = $(BUNDLE_TARGET) ;
			cleanBundleTarget = $(CLEAN_BUNDLE_TARGET) ;
			isysroot = $(ISYSROOT) ;
		}
		if ! $(isysroot) {
			on C.* {
				isysroot = $(ISYSROOT) ;
			}
		}

		# Get task allow value - trying target first, if not set falling back to configuration, if not set defaulting to true.
		getTaskAllowValue = $(C.$(TARGET).GET_TASK_ALLOW) ;
		getTaskAllowValue ?= $(C.*.GET_TASK_ALLOW) ;
		getTaskAllowValue ?= true ;

		local pkginfo = @(PkgInfo:G=$(grist)) ;
		MakeLocate $(pkginfo) : $(bundlePath) ;
		local contents = APPL???? ;
		CONTENTS on $(pkginfo) = $(contents) ;
		WriteFile $(pkginfo) ;
		UseCommandLine $(pkginfo) : $(contents) ;
		Depends $(bundleTarget) : $(pkginfo) ;
		Clean $(cleanBundleTarget) : $(pkginfo) ;
		
		local infoplistcontents ;
		on $(TARGET) infoplistcontents = $(INFO_PLIST) ;
		if $(infoplistcontents) {
			infoplistcontents += "</dict>
</plist>
" ;
			infoplistcontents = $(infoplistcontents:J="") ;

			local infoplist = @(Info.plist:G=$(grist)) ;
			MakeLocate $(infoplist) : $(bundlePath) ;
			CONTENTS on $(infoplist) = $(infoplistcontents) ;
			WriteFile $(infoplist) ;
			
			UseCommandLine $(infoplist) : $(infoplistcontents) ;
			Depends $(bundleTarget) : $(infoplist) ;
			Clean $(cleanBundleTarget) : $(infoplist) ;
		}
	
		if $(PLATFORM) in ipad iphone {	
			# Copy ResourceRules.plist.
			local sourceResourceRulesPlist = @(ResourceRules.plist:G=$(grist)|source) ;
			SEARCH on $(sourceResourceRulesPlist) = $(isysroot) ;
			local destResourceRulesPlist = @(ResourceRules.plist:G=$(grist)) ;
			MakeLocate $(destResourceRulesPlist) : $(bundlePath) ;

			Depends $(bundleTarget) : $(destResourceRulesPlist) : $(sourceResourceRulesPlist) ;	
			Clean $(cleanBundleTarget) : $(destResourceRulesPlist) ;
			CpResource $(destResourceRulesPlist) : $(sourceResourceRulesPlist) ;

			# Create Entitlements.plist.
			local sourceEntitlementsPlist = @(Entitlements.plist:G=$(grist)|source) ;
			SEARCH on $(sourceEntitlementsPlist) = $(isysroot) ;
			local destEntitlementsPlist = @(Entitlements.plist:G=$(grist)) ;
			MakeLocate $(destEntitlementsPlist) : $(LOCATE_TARGET) ;
			ENTITLEMENTS on $(TARGET) = $(destEntitlementsPlist) ;
			Depends $(bundleTarget) : $(destEntitlementsPlist) : $(sourceEntitlementsPlist) ;
			local getTaskAllow = "<key>get-task-allow<\\/key><$(getTaskAllowValue)\\/>" ;
			GET_TASK_ALLOW on $(destEntitlementsPlist) = $(getTaskAllow) ;
			on $(TARGET) UseCommandLine $(destEntitlementsPlist) : $(CFBundleIdentifier) $(AppIdentifierPrefix) $(getTaskAllow) ;
			Clean $(cleanBundleTarget) : $(destEntitlementsPlist) ;
			ProcessEntitlements $(destEntitlementsPlist) : $(sourceEntitlementsPlist) : $(TARGET) ;
		}
	}
	
	C.GenerateDSYMFile $(TARGET) ;
}


if $(TARGETINFO_LOCATE) {

rule XIB
{

}

rule C.SetTaskAllow TARGET : VALUE
{
}

rule C.Provision TARGET
{
}

rule C.CodeSign TARGET
{
}


rule C._ApplicationTargetInfo
{
	if $(PLATFORM) in ipad iphone {
		local isysroot ;
		on $(TARGET) {
			isysroot = $(ISYSROOT) ;
		}
		if ! $(isysroot) {
			on C.* {
				isysroot = $(ISYSROOT) ;
			}
		}
		
		# Create Entitlements.plist.
		local sourceEntitlementsPlist = @(Entitlements.plist:G=$(grist)|source) ;
		SEARCH on $(sourceEntitlementsPlist) = $(isysroot) ;
		local destEntitlementsPlist = @(Entitlements.plist:G=$(grist)) ;
		MakeLocate $(destEntitlementsPlist) : $(LOCATE_TARGET) ;
		Depends all : $(destEntitlementsPlist) : $(sourceEntitlementsPlist) ;
		on $(TARGET) UseCommandLine $(destEntitlementsPlist) : $(CFBundleIdentifier) $(AppIdentifierPrefix) ;
		ProcessEntitlements $(destEntitlementsPlist) : $(sourceEntitlementsPlist) : $(TARGET) ;

		Contents += "Projects[ [[$(TARGET)]] ].XCODE_ENTITLEMENTS[ [[$(PLATFORM)]] ][ [[$(CONFIG)]] ] = [[$(destEntitlementsPlist:T)]]

" ;
	}
}

} else {

rule XIB PARENT : SOURCES : THE_CONFIG : THE_PLATFORM
{
	PARENT = [ _retrieveActiveTargetName $(PARENT) ] ;
	THE_CONFIG ?= $(CONFIG) ;
	THE_PLATFORM ?= $(PLATFORM) ;
	
	local bundlePath ;
	on $(PARENT) bundlePath = $(BUNDLE_PATH) ;

	if $(bundlePath) = ""
	{
		Echo *** XIB $(PARENT) \: $(SOURCES) \: $(THE_CONFIG) \: $(THE_PLATFORM) ;
		Exit *** Bundle path not setup for target $(TARGET) ;
	}

	local grist = $(PARENT) ;
	SOURCES = $(SOURCES:G=$(grist)) ;
	SEARCH on $(SOURCES) = $(SEARCH_SOURCE) ;
	
	local targets = $(SOURCES:S=.nib) ;
	
	#MakeLocate $(targets) : $(bundlePath) ;
	# HACK:
	# The main NIB file has to be in the root of the package, so strip directories.
	targets = $(targets:D="") ;

	MakeLocate $(targets) : $(targets:DR=$(bundlePath)) ;
	BINDING on $(targets) = $(targets:BS) ;
	Clean clean:$(PARENT) : $(targets) ;	
	
	Depends $(PARENT) : $(targets) ;

	local source ;
	for source in $(SOURCES)
	{
		local target = $(source:S=.nib) ;
		
		# HACK:
		# The main NIB file has to be in the root of the package, so strip directories.
		target = $(target:D="") ;
		
		Depends $(target) : $(source) ;
	
		CompileXIB $(target) : $(source) ;
	}
}

actions CompileXIB
{
	PATH=$(MACOSX_SDK_DEVELOPER_ROOT)/usr/bin:$PATH
	/Developer/usr/bin/ibtool --errors --warnings --notices --output-format human-readable-text --compile $(1:C) $(2:C)
}

rule C.Provision TARGET : PROFILE_ID
{
	# Find profile from GUID.
	local _profileDir = "$(HOME)/Library/MobileDevice/Provisioning Profiles" ;

	# Open each profile and search for : "<string>$(PROFILE_ID)</string>"
	local _mobileProvisions = [ Glob $(_profileDir) : *.mobileprovision ] ;

	local _matchingProvision = "" ;

	local _mobileProvision ;
	for _mobileProvision in $(_mobileProvisions)
	{
		local _cmd = "cat \"$(_mobileProvision)\" | grep \"<string>$(PROFILE_ID)</string>\"" ;
		result = [ Shell $(_cmd) ] ;
		if $(result) != ""
		{
			_matchingProvision = $(_mobileProvision) ;
		}
	}

	if $(_matchingProvision) = ""
	{
		Exit *** No mobile provisions found that match PROFILE_ID \: $(PROFILE_ID) ;
	}

	# Get bundle path.
	local _bundlePath = "" ;
	on $(TARGET) _bundlePath = $(BUNDLE_PATH) ;

	if $(_bundlePath) = ""
	{
		Echo *** C.Provision $(TARGET) \: $(PROFILE_ID) ;
		Exit *** Bundle path not setup for target $(TARGET) ;
	}

	# Copy provision into the bundle and name it embedded.mobileprovision
	CopyFile $(TARGET) : $(_bundlePath)/embedded.mobileprovision : $(_matchingProvision) ;
}

actions C._CodeSignWithoutEntitlements
{
	/usr/bin/codesign -f -s "$(PROVISIONING_PROFILE)" --resource-rules="$(BUNDLE_PATH)/ResourceRules.plist" $(BUNDLE_PATH)
}

actions C._CodeSign
{
	/usr/bin/codesign -f -s "$(PROVISIONING_PROFILE)" --resource-rules="$(BUNDLE_PATH)/ResourceRules.plist" --entitlements $(ENTITLEMENTS:CT) $(BUNDLE_PATH)
}


rule C.CodeSign TARGET : PROVISIONING_PROFILE
{
	local bundleExe ;
	local linkTarget ;

	on $(TARGET) {
		bundleExe = $(BUNDLE_EXE) ;
		linkTarget = $(LINK_TARGET) ;
	}

	# Bundle exe depends on link target.
	Depends $(bundleExe) : $(linkTarget) ;
	C.Strip $(bundleExe) : $(linkTarget) ;

	if $(PLATFORM) in ipad iphone {
		local bundlePath ;
		local bundleTarget ;
		local cleanBundleTarget ;
		local entitlements ;

		on $(TARGET) {
			bundlePath = $(BUNDLE_PATH) ;
			bundleTarget = $(BUNDLE_TARGET) ;
			cleanBundleTarget = $(CLEAN_BUNDLE_TARGET) ;
			entitlements = $(ENTITLEMENTS) ;
		}

		local codeResources = [ C.TargetGrist $(TARGET) : CodeResources ] ;
		MakeLocate $(codeResources) : $(bundlePath)/_CodeSignature ;

		# Setup dependency between code resources (signature) and the bundle target, because if anything
		# changes with the bundle target (file being copied into it for example) the signature needs
		# updating.
		Depends $(codeResources) : $(bundleTarget) ;

		local codeResourcesSymbolicLink = [ C.TargetGrist $(TARGET) : CodeResourcesLink ] ;
		BINDING on $(codeResourcesSymbolicLink) = CodeResources ;
		MakeLocate $(codeResourcesSymbolicLink) : $(bundlePath) ;

		BUNDLE_PATH on $(codeResources) = $(bundlePath) ;
		ENTITLEMENTS on $(codeResources) = $(entitlements) ;
		PROVISIONING_PROFILE on $(codeResources) = $(PROVISIONING_PROFILE) ;

		# Code signing depends on bundle (stripped) exe.
		local dependsList = [ DependsList $(bundleTarget) ] $(bundleExe) $(entitlements) ;
		C._CodeSign $(codeResources) : $(dependsList) ; 

		UseCommandLine $(codeResources) : $(dependsList) ;
		Depends $(TARGET) : $(codeResources) : $(dependsList) ;
		Clean $(cleanBundleTarget) : $(codeResources) $(codeResourcesSymbolicLink) $(bundleExe) ;
	}
}


rule C.BundleArchive TARGET : PROVISIONING_PROFILE : OUTPUT_PATH : URL
{
	# Set up the archive support.
	if $(PLATFORM) in ipad iphone {
		TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;

		local bundlePath ;
		local linkTarget ;

		on $(TARGET) {
			bundlePath = $(BUNDLE_PATH) ;
			linkTarget = $(LINK_TARGET) ;
		}

		local archiveTarget = archive:$(TARGET) ;
		NotFile $(archiveTarget) ;

		local ipaTarget = @($(bundlePath:D=:S=).ipa:G=$(TARGET)) ;
		MakeLocate $(ipaTarget) : $(OUTPUT_PATH) ;
		Depends $(archiveTarget) : $(ipaTarget) : $(linkTarget) ;
		Clean clean:$(TARGET) : $(ipaTarget) ;
		BUNDLE_PATH on $(ipaTarget) = $(bundlePath) ;
		PROVISIONING_PROFILE on $(ipaTarget) = $(PROVISIONING_PROFILE) ;
		C._BundleArchive $(ipaTarget) : $(linkTarget) ;

		if $(URL) {
			# Stolen from BetaBuilder:

			# Write manifest.plist.
			local manifest.plist = @(manifest.plist:G=$(TARGET):archive) ;
			MakeLocate $(manifest.plist) : $(OUTPUT_PATH) ;
			Depends $(archiveTarget) : $(manifest.plist) ;
			Clean clean:$(TARGET) : $(manifest.plist) ;
			local contents ;
			on $(TARGET) contents = "
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>items</key>
	<array>
		<dict>
			<key>assets</key>
			<array>
				<dict>
					<key>kind</key>
					<string>software-package</string>
					<key>url</key>
					<string>$(URL)/$(ipaTarget:D=:G=)</string>
				</dict>
			</array>
			<key>metadata</key>
			<dict>
				<key>bundle-identifier</key>
				<string>$(CFBundleIdentifier)</string>
				<key>bundle-version</key>
				<string>$(CFBundleVersion)</string>
				<key>kind</key>
				<string>software</string>
				<key>title</key>
				<string>$(CFBundleDisplayName)</string>
			</dict>
		</dict>
	</array>
</dict>
</plist>
" ;	
			CONTENTS on $(manifest.plist) = $(contents) ;
			WriteFile $(manifest.plist) ;
			UseCommandLine $(manifest.plist) : $(contents) ;

			local index.html = @(index.html:G=$(TARGET):archive) ;
			MakeLocate $(index.html) : $(OUTPUT_PATH) ;
			Depends $(archiveTarget) : $(index.html) ;
			Clean clean:$(TARGET) : $(index.html) ;
			local contents ;
			on $(TARGET) contents = "
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<title>Pathstorm</title>
<style type="text/css">
body {background:#fff;margin:0;padding:0;font-family:arial,helvetica,sans-serif;text-align:center;padding:10px;color:#333;font-size:16px;}
#container {width:300px;margin:0 auto;}
h1 {margin:0;padding:0;font-size:14px;}
p {font-size:13px;}
.link {background:#ecf5ff;border-top:1px solid #fff;border:1px solid #dfebf8;margin-top:.5em;padding:.3em;}
.link a {text-decoration:none;font-size:15px;display:block;color:#069;}

</style>
</head>
<body>

<div id="container">

<h1>iOS 4.0 Users:</h1>

<div class="link"><a href="itms-services://?action=download-manifest&url=$(URL)/manifest.plist">Tap Here to Install<br />$(CFBundleDisplayName)<br />On Your Device</a></div>

<p><strong>Link didn't work?</strong><br />
Make sure you're visiting this page on your device, not your computer.</p>

</div>

</body>
</html>
" ;
			CONTENTS on $(index.html) = $(contents) ;
			WriteFile $(index.html) ;
			UseCommandLine $(index.html) : $(contents) ;

		}
	}
}

actions C._BundleArchive
{
	/usr/bin/xcrun -sdk iphoneos PackageApplication -v "$(BUNDLE_PATH)" -o "$(1)" --sign "$(PROVISIONING_PROFILE)" --embed "$(BUNDLE_PATH)/embedded.mobileprovision"
}

if $(PLATFORM) in iphone iphonesimulator
{
	C.Defines * : _IPHONE ;
}
else if $(PLATFORM) in ipad ipadsimulator
{
	C.Defines * : _IPHONE _IPAD ;
}


} # TARGETINFO_LOCATE

