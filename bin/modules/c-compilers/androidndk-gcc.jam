######################################################################################################################
C.AR			= "$(NDK_TOOLCHAIN_ROOT)/bin/arm-linux-androideabi-ar$(HOST_SUFEXE)" ruc ;
C.CC			= "$(NDK_TOOLCHAIN_ROOT)/bin/arm-linux-androideabi-gcc$(HOST_SUFEXE)" ;
C.C++			= "$(NDK_TOOLCHAIN_ROOT)/bin/arm-linux-androideabi-g++$(HOST_SUFEXE)" ;
C.LINK			= "$(NDK_TOOLCHAIN_ROOT)/bin/arm-linux-androideabi-gcc$(HOST_SUFEXE)" ;
C.RANLIB		= "$(NDK_TOOLCHAIN_ROOT)/bin/arm-linux-androideabi-ranlib$(HOST_SUFEXE)" ;
C.STRIP			= "$(NDK_TOOLCHAIN_ROOT)/bin/arm-linux-androideabi-strip.exe" ;

######################################################################################################################

PROPER_STRIP = true ;
TARGET_ARMV7 = false ;

######################################################################################################################
# Our 'exe' is actually a shared lib, so make extension .so file.
SUFEXE		= .so ;
SUFMODULE	= .so ;

######################################################################################################################
	
NDK_MAIN_LIB_DIR	=  $(NDKROOT)/platforms/$(NDK_PLATFORM)/arch-arm/usr/lib ;
NDK_SEC_LIB_DIR		=  $(NDK_TOOLCHAIN_ROOT)/lib/gcc/arm-linux-androideabi/4.4.3 ;

NDK_MAIN_INC_DIR	=  $(NDKROOT)/platforms/$(NDK_PLATFORM)/arch-arm/usr/include ;
NDK_SEC_INC_DIR		=  $(NDK_TOOLCHAIN_ROOT)/lib/gcc/arm-linux-androideabi/4.4.3/include ;

STL_PORT_BASE		?= $(NDKROOT)/sources/cxx-stl/stlport ;
STL_PORT_INCLUDE	=  $(STL_PORT_BASE)/stlport ;

######################################################################################################################

rule C.FDefines { return -D$(<) ; }
rule C.FIncludes { return -I\"$(<)\" ; }
rule C.FLibraryPaths { return -L\"$(<)\" ; } 

######################################################################################################################

COMPILE_FLAGS = 
	-mandroid 
	-fpic 
	-ffunction-sections 
	-fdata-sections 
	-funwind-tables 
	-fstack-protector 
	-fno-short-enums 
	-fno-strict-aliasing 
	-fvisibility=hidden 
	-w
	-Wno-psabi
	-Wa,--noexecstack
	-Wreturn-type 
	-fsigned-char
	-ffast-math
	-finline-small-functions
	;
	
if $(TARGET_ARMV7) = true
{
	COMPILE_FLAGS += 
		-march=armv7-a 
		-mfloat-abi=softfp
		-mfpu=vfp 
		;
}
else
{
	COMPILE_FLAGS += 
		-march=armv5te	
		-msoft-float 
		-mtune=xscale 
		-mthumb-interwork
		-marm
		;
}
	
COMPILE_FLAGS_DEBUG =
	-fno-omit-frame-pointer
	-finline-limit=64
	-O0
	-g
	;
	
COMPILE_FLAGS_RELEASE =
	-fno-omit-frame-pointer 
	-funswitch-loops
	-finline-limit=300
	-Os
	;

######################################################################################################################

C.CFlags * : $(COMPILE_FLAGS) ;
C.CFlags * : $(COMPILE_FLAGS_DEBUG)		: debug ;
C.CFlags * : $(COMPILE_FLAGS_RELEASE)	: release final ;

######################################################################################################################

C.C++Flags * : 
	$(COMPILE_FLAGS)
	-fvisibility-inlines-hidden
	-fno-exceptions
	-fno-rtti
	;
	
C.C++Flags * : $(COMPILE_FLAGS_DEBUG) : debug ;
C.C++Flags * : $(COMPILE_FLAGS_RELEASE) : release final ;

######################################################################################################################

C.Defines * :
	__ARM_ARCH_5__ 
	__ARM_ARCH_5T__ 
	__ARM_ARCH_5E__ 
	__ARM_ARCH_5TE__
	ANDROID
	_ANDROID
	OS_ANDROID 
	;
	
C.Defines * : _DEBUG : debug ;
C.Defines * : NDEBUG : release ;
C.Defines * : NDEBUG _FINAL : final ;

######################################################################################################################
# Another flag, -Wl,-soname is set when linking as it contains the link target name that isn't accessible yet.

C.LinkFlags * :
	-nostdlib 
	-Wl,-shared,-Bsymbolic
	-Wl,--no-undefined
	-Wl,-rpath-link=\"$(NDK_MAIN_LIB_DIR)\"
	-Wl,--gc-sections
	-g
	;

if $(PROPER_STRIP) = true
{
	C.LinkFlags * : -Wl,--strip-all ;	
}	
	
######################################################################################################################

C.LinkDirectories * :
	$(NDK_MAIN_LIB_DIR)
	;

######################################################################################################################
# TODO : Currently links against GLES, dl (for opening the GLES dynamic library) and log (for log messages), as well
# as the real basics libc, libstdc++, libm, libgcc. Also links against stlport.

C.LinkPrebuiltLibraries * :
	$(NDK_MAIN_LIB_DIR)/libc.so
	$(NDK_MAIN_LIB_DIR)/libstdc++.so
	$(NDK_MAIN_LIB_DIR)/libm.so

	$(NDK_MAIN_LIB_DIR)/libGLESv1_CM.so
	$(NDK_MAIN_LIB_DIR)/libdl.so
	$(NDK_MAIN_LIB_DIR)/liblog.so
	$(STL_PORT_BASE)/libs/$(NDK_ABI)/libstlport_static.a
	
	$(NDK_SEC_LIB_DIR)/libgcc.a
	;

######################################################################################################################

C.IncludeDirectories * :
	$(NDK_MAIN_INC_DIR) 
	$(STL_PORT_INCLUDE)
	$(NDK_SEC_INC_DIR)
	;

######################################################################################################################

VSPLATFORMMAP.androidndk = "Android NDK" ;

######################################################################################################################
# Using custom C.Link as we need to specify the exectuable name as part of the flags, and using custom rules for
# everything else as we need to do some cygwin setup first. Ideally we'd share the actions in g-gcc and just do our
# cygwin setup first, but I'm not sure if that is possible to do right now.

actions response C.Link
{
	"$(C.LINK)" -Wl,-soname,$(<[1]:CBS) @@($(LINKFLAGS) $(>:C) $(NEEDLIBS:CT) $(LINKLIBS:CT)) -o $(<[1]:C)
}

actions updated together piecemeal response C.Archive
{
	"$(C.AR)" @@($(LIBFLAGS) $(<:C) $(>:C))
}

actions together C.Ranlib
{
	"$(C.RANLIB)" $(<:C)
}

if $(NOARUPDATE)
{
	actions response C.Archive
	{
		"$(C.AR)" @@($(LIBFLAGS) $(<:C)) $(>:C)
	}
}

actions updated response C.CC
{
	CD /D $(<[0]:D\\C)
	"$(C.CC)" @@(-c $(MFLAGS)) $(>:C)
}

actions updated response C.C++
{
	CD /D $(<[0]:D\\C)
	"$(C.C++)" @@(-c $(MFLAGS)) $(>:C)
}

actions updated response C.PCH
{
	"$(C.C++)" @@(-c $(MFLAGS)) $(>:C)
}

######################################################################################################################

rule C._ApplicationFromObjects_PostBuild_Platform
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	local _s = $(OBJECTS:G=$(grist)) ;
	local _t = [ C._retrieveOutputName $(TARGET) : SUFEXE ] ;
	_t = $(_t:G=$(grist)) ;
	
	# Create stripped .so
	local _strippedLib = $(_t).stripped ;
	MakeLocate $(_strippedLib) : $(outputPath) ;
	Depends $(TARGET) : $(_strippedLib) : $(_t) ;
	Clean clean:$(TARGET) : $(_strippedLib) ;
	C.Strip $(_strippedLib) : $(_t) ;
}

if $(PROPER_STRIP) = true
{
	actions C.Strip
	{
		$(CYGWIN_SETUP)
		$(C.STRIP) -g -S -d -o $(1) $(2)
	}
}
else
{
	actions C.Strip
	{
		COPY $(2) $(1) /Y > NUL
	}
}
