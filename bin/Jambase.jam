#
# /+\
# +\	Portions copyright 1993-2002 Christopher Seiwald and Perforce Software, Inc.
# \+/
#
# This file is part of Jam - see jam.c for Copyright information.
#

# Helper rule used to get value of a variable bound to specific target.
# [ on <target> Var <var> ]
rule Var {
  return $($(1)) ;
}


# Helper rule used to get value of a variable bound to specific target.
rule SearchVar {
	local key ;
	for key in $(1)
	{
		local value = $($(key)) ;
		if $(value) { return $(value) ; }
	}
	return $(2) ;
}


SPACE = " " ;
TAB = "	" ;
NEWLINE = "
" ;

JAMBASEDATE = 2008.10.08 ;

# Initialize variables
#

CONFIG ?= release ;

VALID_CONFIGS ?= debug release releaseltcg ;
VALID_PLATFORMS ?= win32 ;

PLATFORM ?= win32 ;

if ! $(CONFIG) in * $(VALID_CONFIGS)
{
	Exit * jam: CONFIG must be one of the following: $(VALID_CONFIGS:J=$(SPACE)) ;
}

if ! $(PLATFORM) in * $(VALID_PLATFORMS)
{
	Exit * jam: PLATFORM must be one of the following: $(VALID_PLATFORMS:J=$(SPACE)) ;
}

#
# OS specific variable settings
#

VISUAL_STUDIO_FORCE_VERSION = 9.0 ;

rule FindVisualStudio VERSION
{
	if $(MSVCNT)
	{
		return ;
	}

	switch $(VERSION)
	{
		case 9.0 :
			local key = HKEY_LOCAL_MACHINE SOFTWARE Microsoft VisualStudio $(VERSION) InstallDir ;
			MSVCNT = [ W32_GETREG $(key) ] ;
			VS90COMNTOOLS = $(VS90COMNTOOLS:J=" ") ;
			if ! $(MSVCNT) && $(VS90COMNTOOLS) {
				MSVCNT = $(VS90COMNTOOLS) ;
			}
			if $(MSVCNT)
			{
				MSVCNT = $(MSVCNT)..\\..\\vc ;
				MSVCNT = $(MSVCNT:R=$(MSVCNT)) ;
				MSVCNT_PATH = $(MSVCNT)/../Common7/IDE ;
				VS2008 = 1 ;

				local key = HKEY_LOCAL_MACHINE SOFTWARE Microsoft "Microsoft SDKs" Windows CurrentInstallFolder ;
				MSSDK = [ W32_GETREG $(key) ] ;
				MSSDK ?= $(MSVCNT) ;
				MSSDK_STDHDRS = "$(MSVCNT)/include" "$(MSSDK)/Include" ;
				MSSDK_LINKDIRECTORIES = "$(MSVCNT)/lib" "$(MSSDK)/Lib" ;
				return vs2008 ;
			}

		case 8.0 :
			local key = HKEY_LOCAL_MACHINE SOFTWARE Microsoft VisualStudio $(VERSION) InstallDir ;
			MSVCNT = [ W32_GETREG $(key) ] ;
			if ! $(MSVCNT) && $(VS80COMNTOOLS) {
				MSVCNT = $(VS80COMNTOOLS) ;
			}
			if $(MSVCNT)
			{
				MSVCNT = @($(MSVCNT)..\\..\\VC:R=$(MSVCNT)) ;
				MSVCNT_PATH = @($(MSVCNT)/../Common7/IDE:R=) ;
				VS2005 = 1 ;
				MSSDK = $(MSVCNT) ;
				MSSDK_STDHDRS = "$(MSSDK)/include" "$(MSSDK)/PlatformSDK/Include" ;
				MSSDK_LINKDIRECTORIES = "$(MSVCNT)/lib" "$(MSVCNT)/PlatformSDK/lib" ;
				return vs2005 ;
			}

		case 7.1 :
			local key = HKEY_LOCAL_MACHINE SOFTWARE Microsoft VisualStudio $(VERSION) InstallDir ;
			MSVCNT = [ W32_GETREG $(key) ] ;
			if ! $(MSVCNT) && $(VS71COMNTOOLS) {
				MSVCNT = $(VS71COMNTOOLS) ;
			}
			if $(MSVCNT)
			{
				MSVCNT = $(MSVCNT)\\..\\..\\vc7 ;
				MSVCNT = $(MSVCNT:R=$(MSVCNT)) ;
				MSVCNT_PATH = $(MSVCNT)/../Common7/IDE ;
				MSSDK = $(MSVCNT) ;
				MSSDK_STDHDRS = "$(MSSDK)/include" "$(MSSDK)/PlatformSDK/Include" ;
				MSSDK_LINKDIRECTORIES = "$(MSVCNT)/lib" "$(MSVCNT)/PlatformSDK/lib" ;
				return vs2003 ;
			}

		case 7.0 :
			local key = HKEY_LOCAL_MACHINE SOFTWARE Microsoft
				VisualStudio $(VERSION) InstallDir ;
			MSVCNT = [ W32_GETREG $(key) ] ;
			if ! $(MSVCNT) && $(VS70COMNTOOLS) {
				MSVCNT = $(VS70COMNTOOLS) ;
			}
			if $(MSVCNT)
			{
				MSVCNT = $(MSVCNT)\\..\\..\\vc7 ;
				return vs2002 ;
			}

		case 6.0 :
		    local key = HKEY_LOCAL_MACHINE SOFTWARE Microsoft DevStudio $(VERSION) Products "Microsoft Visual C++" ProductDir ;
		    MSVCNT = [ W32_GETREG $(key) ] ;
			return vc6 ;
	}
}


rule FindMinGW
{
	local PATHS =
		c:/mingw
		d:/mingw
	;

	local gcc = [ Glob $(PATHS)/bin : gcc.exe ] ;
	if ! $(gcc)
	{
		return ;
	}

	MINGW_ROOT = [ Match (.+)/bin : $(gcc[1]) ] ;
}


rule ToolChain THE_COMPILER : THE_PLATFORM : THE_CONFIG
{
	THE_COMPILER ?= $(COMPILER) ;
	THE_PLATFORM ?= $(PLATFORM) ;
	THE_CONFIG ?= $(CONFIG) ;

	if $(NT)
	{
		MSVCNT ?= $(MSVCDIR) ;
		MSVCNT ?= $(MSVCDir) ;

		MV		?= move /y ;
		CP		?= copy ;
		RM		?= del /f/q ;
		RMDIR	?= rmdir /s/q ;
		SLASH	?= / ;
		SUFEXE	?= .exe ;
		SUFMODULE ?= .dll ;
		SUFSHAREDLIB ?= .dll ;
		SUFRES	?= .res ;

		# Do we need to attempt to detect the compiler?
		if ! $(THE_COMPILER)
		{
			if ! $(MSVCNT)
			{
				MSVCNT_PATH = ;
				for ver in $(VISUAL_STUDIO_FORCE_VERSION) 9.0 8.0 7.1 7.0 6.0
				{
					COMPILER = [ FindVisualStudio $(ver) ] ;
					if $(COMPILER)
					{
						break ;
					}
				}
				if ! $(COMPILER)
				{
					Exit ** Unable to find the specified compiler. ;
				}
			}
		}
		else
		{
			COMPILER = $(THE_COMPILER) ;
		}

		if $(COMPILER) in vc6 vs2003 vs2005 vs2008
		{
			SUFLIB	?= .lib ;
			SUFOBJ	?= .obj ;

			MSVCNT = ;
			switch $(COMPILER)
			{
				case vc6 :
					COMPILER = [ FindVisualStudio 6.0 ] ;
				case vs2003 :
					COMPILER = [ FindVisualStudio 7.1 ] ;
					COMPILER ?= [ FindVisualStudio 7.0 ] ;
				case vs2005 :
					COMPILER = [ FindVisualStudio 8.0 ] ;
				case vs2008 :
					COMPILER = [ FindVisualStudio 9.0 ] ;
			}

			DEFINES.win32.* on * += WIN32 WINDOWS _CRT_SECURE_NO_DEPRECATE _CRT_SECURE_NO_WARNINGS _CRT_NONSTDC_NO_DEPRECATE ;

			MSVCNT		?= $(MSVCDIR) ;

			MSVCBIN ?= $(MSVCNT)/bin/ ;

			CCFLAGS.win32.debug on * 		?= /Od /Gm /EHsc /RTC1 /MDd /W3 /Zi ;
			CCFLAGS.win32.release on * 		?= /O2 /Oi /EHsc /Gy /MD /W3 /Zi ;
			CCFLAGS.win32.releaseltcg on * 	?= [ on * Var CCFLAGS.win32.release ] /GL ;
			C++FLAGS.win32.* on *			?= [ on * Var CCFLAGS.win32.* ] ;
			C++FLAGS.win32.debug on *		?= [ on * Var CCFLAGS.win32.debug ] ;
			C++FLAGS.win32.release on *		?= [ on * Var CCFLAGS.win32.release ] ;
			C++FLAGS.win32.releaseltcg on *	?= [ on * Var CCFLAGS.win32.releaseltcg ] ;

			DEFINES.*.debug on * += _DEBUG DEBUG ;
			DEFINES.*.release on * += NDEBUG ;
			DEFINES.*.releaseltcg on * += NDEBUG ;

			LIBFLAGS.win32.debug on * = ;
			LIBFLAGS.win32.release on * = ;
			LIBFLAGS.win32.releaseltcg on * = /LTCG ;

			LINKDIRECTORIES.*.*	on * += $(MSSDK_LINKDIRECTORIES) ;
			LINKFLAGS.win32.debug on * = /INCREMENTAL /DEBUG /MACHINE:X86 ;
			LINKFLAGS.win32.release on * = /INCREMENTAL:NO /DEBUG /MACHINE:X86 /OPT:REF /OPT:ICF ;
			LINKFLAGS.win32.releaseltcg on * = [ on * Var LINKFLAGS.win32.release ] /LTCG ;

			AR			= "$(MSVCBIN)lib" ;
			AS			= "$(MSVCBIN)masm386" ;
			CC			= "$(MSVCBIN)cl" ;
			C++			= "$(CC)" ;
			LINK		= "$(MSVCBIN)link" ;
			MKDIR		= mkdir ;
			MT			= "$(MSSDK)/bin/mt" ;
			RC			= "$(MSSDK)/bin/RC" ;
			STDHDRS		?= "$(MSSDK_STDHDRS)" ;
			UNDEFFLAG	?= "/u _" ;

			NOARSCAN = true ;
			NOARUPDATE = true ;
		}
		else if $(COMPILER) = mingw
		{
			FindMinGW ;

			SUFLIB	?= .a ;
			SUFOBJ	?= .o ;

			DEFINES.*.* on * += MINGW ;
			DEFINES.*.debug on * += _DEBUG DEBUG ;
			DEFINES.*.release on * += NDEBUG ;

			CCFLAGS.win32.debug on * 	= -g -O0 ;
			CCFLAGS.win32.release on * 	= -g -O2 ;
			C++FLAGS.win32.* on *		?= [ on * Var CCFLAGS.win32.* ] ;
			C++FLAGS.win32.debug on *	?= [ on * Var CCFLAGS.win32.debug ] ;
			C++FLAGS.win32.release on *	?= [ on * Var CCFLAGS.win32.release ] ;

			AR			?= "$(MINGW_ROOT)/bin/ar" ru ;
			CC			?= "$(MINGW_ROOT)/bin/gcc" ;
			C++			?= "$(MINGW_ROOT)/bin/g++" ;
			RANLIB		?= "$(MINGW_ROOT)/bin/ranlib" ;
			SUFEXE		?= .exe ;

			NOARSCAN = true ;
			NOARUPDATE = true ;
		}
		else
		{
			EXIT On NT, set BCCROOT, MSVCDIR, MSVCNT, or MSVC to the root
				of the Borland or Microsoft directories. ;
		}
	}
	else if $(UNIX)
	{
		COMPILER = gcc ;

		SUFLIB	?= .a ;
		SUFOBJ	?= .o ;

		SUFSHAREDLIB ?= .so ;
		SUFMODULE ?= .so ;

		NOARSCAN = true ;
		NOARUPDATE = true ;

		DEFINES.*.debug on * += _DEBUG DEBUG ;
		DEFINES.*.release on * += NDEBUG ;

		CCFLAGS.win32.debug on * 	= -g -O0 ;
		CCFLAGS.win32.release on * 	= -g -O2 ;
		C++FLAGS.win32.* on *		?= [ on * Var CCFLAGS.win32.* ] ;
		C++FLAGS.win32.debug on *	?= [ on * Var CCFLAGS.win32.debug ] ;
		C++FLAGS.win32.release on *	?= [ on * Var CCFLAGS.win32.release ] ;

		switch $(OS)
		{
			case CYGWIN :
				DEFINES.*.* on * += __cygwin__ ;
				CC			?= gcc ;
				C++			?= g++ ;
				JAMSHELL	?= sh -c ;
				RANLIB		?= "" ;
				SUFEXE		?= .exe ;

			case MACOSX :
				DEFINES.*.* on * += ;
				CC			?= gcc ;
				C++			?= g++ ;
				LINK		?= $(C++) ;
				SUFMODULE	= .dylib ;

		}

		# UNIX defaults

		CCFLAGS		?= ;
		C++FLAGS	?= $(CCFLAGS) ;
		CHMOD		?= chmod ;
		CHGRP		?= chgrp ;
		CHOWN		?= chown ;
		LINKFLAGS	?= $(CCFLAGS) ;
		LINKLIBS	?= ;
		OPTIM		?= -O ;
		RANLIB		?= ranlib ;
	}


	#
	# General defaults; a lot like UNIX
	#

	AR			?= ar ru ;
	AS			?= as ;
	ASFLAGS		?= ;
	AWK			?= awk ;
	BINDIR		?= /usr/local/bin ;
	C++			?= cc ;
#	C++FLAGS	?= ;
	CC			?= cc ;
#	CCFLAGS		?= ;
	CP			?= cp -f ;
	CRELIB		?= ;
	DOT			?= . ;
	DOTDOT		?= .. ;
	HDRS		?= ;
	JAMFILE		?= Jamfile.jam ;
	JAMRULES	?= Jamrules.jam ;
	LIBDIR		?= /usr/local/lib ;
	LINK		?= $(CC) ;
	LINKFLAGS	?= ;
	LINKLIBS	?= ;
	LN			?= ln ;
	MKDIR		?= mkdir -p ;
	MV			?= mv -f ;
	RM			?= rm -f ;
	RMDIR		?= $(RM) ;
	SLASH		?= / ;
	STDHDRS		?= /usr/include ;
	SUBDIRRULES ?= ;
	SUBDIRRESET ?= ASFLAGS HDRS C++FLAGS CCFLAGS ;
	SUFEXE		?= "" ;
	SUFLIB		?= .a ;
	SUFOBJ		?= .o ;
	UNDEFFLAG	?= "-u _" ;
}


HDRPATTERN =
		"^[ 	]*#[ 	]*include[ 	]*[<\"]([^\">]*)[\">].*$" ;

OSFULL = $(OS)$(OSVER)$(OSPLAT) $(OS)$(OSPLAT) $(OS)$(OSVER) $(OS) ;

ToolChain $(COMPILER) : $(PLATFORM) : $(CONFIG) ;


#
# Base dependencies - first for "bootstrap" kinds of rules
#

NotFile all allclean clean ;
Always allclean clean ;

#
# Rules
#

rule HdrRule SOURCE : HEADERS
{
	# HdrRule source : headers ;

	# N.B.	This rule is called during binding, potentially after
	# the fate of many targets has been determined, and must be
	# used with caution: don't add dependencies to unrelated
	# targets, and don't set variables on $(SOURCE).

	# Tell Jam that anything depending on $(SOURCE) also depends on $(HEADERS),
	# set SEARCH so Jam can find the headers, but then say we don't
	# care if we can't actually find the headers (they may have been
	# within ifdefs),

	local s = $(HEADERS:G=$(HDRGRIST:E)) ;

	Includes $(SOURCE) : $(s) ;
## LOCAL CHANGE

	# If the directory holding this header isn't in HDRSEARCH,
	# add it, or Jam won't be able to find it internally and will
	# think it is stable in other projects.
	#
	# See http://maillist.perforce.com/pipermail/jamming/2001-December/001482.html
	if ! $(3:D) in $(HDRSEARCH)
	{
	    HDRSEARCH += $(3:D) ;
	}

## LOCAL CHANGE
	SEARCH on $(s) = $(HDRSEARCH) ;
	NoCare $(s) ;

	# Propagate on $(SOURCE) to $(HEADERS)

	HDRSEARCH on $(s) = $(HDRSEARCH) ;
	HDRSCAN on $(s) = $(HDRSCAN) ;
	HDRRULE on $(s) = $(HDRRULE) ;
	HDRGRIST on $(s) = $(HDRGRIST) ;
}


rule IncludeModule MODULE_NAME
{
	local include_marker = included_module_$(MODULE_NAME:J=_) ;
	if $($(include_marker))
	{
		return ;
	}
	$(include_marker) = true ;

	include $(JAM_PROCESS_PATH)/jammodules/$(MODULE_NAME).jam ;
}


rule FGristDirectories DIRECTORIES
{
	return $(DIRECTORIES:G=!dir!) ;
}


rule MakeLocate
{
	# MakeLocate targets : directory ;

	# Sets special variable LOCATE on targets, and arranges
	# with MkDir to create target directory.

	# Note we grist the directory name with 'dir',
	# so that directory path components and other
	# targets don't conflict.

	if $(>)
	{
	    LOCATE on $(<) = $(>) ;
	    Depends $(<) : $(>[1]:G=!dir!) ;
	    MkDir $(>[1]:G=!dir!) ;
	}
}

rule MkDir
{
	# MkDir directory ;

	# Make a directory and all its parent directories.

	# Ignore timestamps on directories: we only care if they
	# exist.

	NoUpdate $(<) ;

	# Don't create . or any directory already created.

	if $(<:G=) = $(DOT)
	{
		NotFile $(<) ;
	}
	else if ! $($(<)-mkdir)
	{
	    # Cheesy gate to prevent multiple invocations on same dir
	    # Arrange for jam dirs
	    # MkDir1 has the actions

	    $(<)-mkdir = true ;
	    MkDir1 $(<) ;

	    # Recursively make parent directories.
	    # $(<:P) = $(<)'s parent, & we recurse until root

	    local s = $(<:P) ;

	    # Don't try to create A: or A:\ on windows

	    if $(NT)
	    {
	        switch $(s)
		{
		case *:   : s = ;
		case *:\\ : s = ;
		case *:/ : s = ;
		}
	    }

	    if $(s) = $(<)
	    {
		# The parent is the same as the dir.
		# We're at the root, which some OS's can't stat, so we mark
		# it as NotFile.

	        NotFile $(s) ;
	    }
	    else if $(s:G=)
	    {
		# There's a parent; recurse.

		Depends $(<) : $(s) ;
		MkDir $(s) ;
	    }
	}
}

rule RmTemps
{
	Temporary $(>) ;
}

rule SubDir
{
	#
	# SubDir TOP d1 d2 ... ;
	#
	# Support for a project tree spanning multiple directories.
	#
	# SubDir declares a Jamfile's location in a project tree, setting
	# Jambase variables (SEARCH_SOURCE, LOCATE_TARGET) so that source
	# files can be found.
	#
	# TOP is a user-select variable name for root of the tree, and
	# d1 d2 ...  are the directory elements that lead from the root
	# of the tree to the directory of the Jamfile.
	#
	# TOP can be set externally, but normally the first SubDir call
	# computes TOP as the path up from the current directory; the
	# path contains one ../ for each of d1 d2 ...
	#
	# SubDir reads once the project-specific rules file Jamrules
	# in the TOP directory, if present.  This can be overridden
	# with the variable TOPRULES.
	#
	# SubDir supports multiple, overlaid project trees:  SubDir
	# invocations with different TOPs can appear in the same Jamfile.
	# The location established by the first SubDir call is used set
	# the TOPs for the subsequent SubDir calls.
	#
	# SubDir's public variables:
	#
	#	$(TOP) = path from CWD to root.
	#	$(SUBDIR) = path from CWD to the directory SubDir names.
	#	$(SUBDIR_TOKENS) = path from $(TOP) to $(SUBDIR) as dir names
	#	$(SEARCH_SOURCE) = $(SUBDIR)
	#	$(LOCATE_SOURCE) = $(ALL_LOCATE_TARGET) $(SUBDIR)
	#	$(LOCATE_TARGET) = $(ALL_LOCATE_TARGET) $(SUBDIR)
	#	$(SOURCE_GRIST) = $(SUBDIR_TOKENS) with !'s
	#

	local _top = $(<[1]) ;
	local _tokens = $(<[2-]) ;

	ALL_SUBDIR_TOKENS = $(<) ;

	#
	# First time through sets up relative root and includes Jamrules.
	#

	if ! $(_top)
	{
	    Exit SubDir syntax error ;
	}

	if ! $($(_top)-SET)
	{
	    $(_top)-SET = true ;

	    # First time we've seen this TOP.
	    # We'll initialize a number of internal variables:
	    #
	    #	$(TOP-UP) = directories from ROOT to a common point
	    #	$(TOP-DOWN) = directories from common point to TOP
	    #	$(TOP-ROOT) = root directory for UP/DOWN -- normally CWD
	    #	$(SUBDIR_UP) = current value of $(TOP-UP)
	    #	$(SUBDIR_DOWN) = current value of $(TOP-DOWN)
	    #	$(SUBDIR_ROOT) = current value of $(TOP-ROOT)
	    #

	    if $($(_top))
	    {
			# TOP externally set.
			# We'll ignore the relative (UP/DOWN) path that
			# got us here, and instead remember the hard ROOT.

			$(_top)-UP = ;
			$(_top)-DOWN = ;
			$(_top)-ROOT = $($(_top)) ;
	    }
	    else
	    {
			# TOP not preset.

			# Establishing a new TOP.  In the simplest case,
			# (SUBDIR_UP/SUBDIR_DOWN/SUBDIR_ROOT unset), it's
			# merely a certain number of directories down from
			# the current directory, and FSubDirPath will set
			# TOP to a path consisting of ../ for each of the
			# elements of _tokens, because that represents how
			# far below TOP the current directory sits.
			#
			# In the more complicated case, the starting directory
			# isn't the directory of jam's invocation but an
			# location established by previous SubDir call.  The
			# starting directory is SUBDIR_UP directories up from
			# SUBDIR_ROOT, and then SUBDIR_DOWN directories down
			# from that.   If SUBDIR_ROOT is not set, that means
			# SUBDIR_DOWN and SUBDIR_UP represent the path from
			# the directory of jam's invocation.
			#
			# In the most complicated case, the _tokens also
			# represents directories down, because TOP is being
			# estalished in a directory other than TOP's root.
			# Hopefully, _tokens and SUBDIR_DOWN represent the
			# same final directory, relative to the new TOP and
			# the previous SubDIr's TOP.  To find the new TOP,
			# we have to chop off any common directories from
			# then ends of _tokens and SUBDIR_DOWN.  To do so,
			# we reverse each of them, call FStripCommon to
			# remove the initial common elements, and then
			# reverse them again.  After this process, if
			# both _tokens and SUBDIR_DOWN have elements, it
			# means the directory names estalished by the two
			# SubDir calls don't match, and a warning is issued.
			# All hell will likely break loose at this point,
			# since the whole SubDir scheme relies on the SubDir
			# calls accurately naming the current directory.

			# Strip common trailing elements of _tokens and SUBDIR_DOWN.

			_tokens = [ FReverse $(_tokens) ] ;
			SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;
			FStripCommon _tokens : SUBDIR_DOWN ;
			SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;
			_tokens = [ FReverse $(_tokens) ] ;

			if $(SUBDIR_DOWN) && $(_tokens)
			{
				Echo Warning: SubDir $(<) misplaced! ;
			}

			# We'll remember the relative (UP/DOWN) path that
			# got us here, plus any hard ROOT starting point
			# for the UP/DOWN.  If TOP is never set externally,
			# ROOT will always be "" (directory of jam's invocation).

			$(_top)-UP = $(SUBDIR_UP) $(_tokens) ;
			$(_top)-DOWN = $(SUBDIR_DOWN) ;
			$(_top)-ROOT = $(SUBDIR_ROOT:E="") ;
			$(_top) = [ FSubDirPath $(_top) ] ;
			$(_top) = $($(_top):R=$(CWD)) ;

			$(_top)-ROOT = $($(_top)) ;
			$(_top)-UP = ;
			$(_top)-DOWN = ;
	    }

	    # Set subdir vars for the inclusion of the Jamrules,
	    # just in case they have SubDir rules of their own.
	    # Note that SUBDIR_DOWN is empty: it's all the way
	    # up where the Jamrules live.  These gets overrided
	    # just after the inclusion.

	    SUBDIR_UP = $($(_top)-UP) ;
	    SUBDIR_DOWN = ;
	    SUBDIR_ROOT = $($(_top)-ROOT) ;

	    # Include $(TOPRULES) or $(TOP)/Jamrules.
	    # Include $(TOPRULES) if set.
	    # Otherwise include $(TOP)/Jamrules if present.

	    if $($(_top)RULES) {
			include $($(_top)RULES) ;
	    } else {
			NoCare $(JAMRULES:R=$($(_top)):G=$(_top)) ;
			include $(JAMRULES:R=$($(_top)):G=$(_top)) ;
			NoCare @($(_top).jamrules:R=$($(_top)):G=$(_top)) ;
			include @($(_top).jamrules:R=$($(_top)):G=$(_top)) ;
	    }
	}

	# Get path from $(TOP) to named directory.
	# Save dir tokens for other potential uses.

	SUBDIR_UP = $($(_top)-UP) ;
    SUBDIR_DOWN = $($(_top)-DOWN) $(_tokens) ;
	SUBDIR_ROOT = $($(_top)-ROOT) ;
    SUBDIR_TOKENS = $(SUBDIR_DOWN) ;

	SUBDIR = [ FSubDirPath $(<) ] ;

	# Now set up SEARCH_SOURCE, LOCATE_TARGET, SOURCE_GRIST
	# These can be reset if needed.	 For example, if the source
	# directory should not hold object files, LOCATE_TARGET can
	# subsequently be redefined.

	local target = /$(>) ;

	SEARCH_SOURCE = $(SUBDIR) ;
	LOCATE_SOURCE = [ FDirName $(ALL_LOCATE_TARGET) $(SUBDIR_DOWN) ] ;
	LOCATE_SOURCE = $(LOCATE_SOURCE)$(target:E=) ;
	LOCATE_TARGET = [ FDirName $(ALL_LOCATE_TARGET) $(SUBDIR_DOWN) ] ;
	LOCATE_TARGET = $(LOCATE_TARGET)$(target:E=) ;
	SOURCE_GRIST = [ FGrist $(ALL_SUBDIR_TOKENS) ] ;
	SOURCE_GRIST = $(SOURCE_GRIST)$(target:E=) ;
	## LOCAL CHANGE -- OPT_HEADER_CACHE_EXT.  With the header
	# cache, we can grist all files found during a header scan
	# without incurring a performance penalty.
	#
	HDRGRIST = $(SOURCE_GRIST) ;
	#
	## LOCAL CHANGE

	# Reset per-directory ccflags, hdrs, etc,
	# listed in SUBDIRRESET.
	# Note use of variable expanded assignment var

	SUBDIR$(SUBDIRRESET) = ;

	# Invoke user-specific SubDir extensions,
	# rule names listed in SUBDIRRULES.
	# Note use of variable expanded rule invocation

	$(SUBDIRRULES) $(<) ;
}

rule FSubDirPath
{
	# FSubDirPath TOP d1 ... ;

	# Returns path to named directory.

	# If jam is invoked in a subdirectory of the TOP, then we
	# need to prepend a ../ for every level we must climb up
	# (TOP-UP), and then append the directory names we must
	# climb down (TOP-DOWN), plus the named directories d1 ...
	# If TOP was set externally, or computed from another TOP
	# that was, we'll have to reroot the whole thing at TOP-ROOT.

	local _r = [ FRelPath $($(<[1])-UP) : $($(<[1])-DOWN) $(<[2-]) ] ;

	return $(_r:R=$($(<[1])-ROOT)) ;
}

rule SubDirCcFlags
{
	SUBDIRCCFLAGS += $(<) ;
}

rule SubDirC++Flags
{
	SUBDIRC++FLAGS += $(<) ;
}

rule SubDirHdrs
{
	SUBDIRHDRS += [ FDirName $(<) ] ;
}

rule SubInclude
{
	# SubInclude TOP d1 ... ;
	#
	# Include a subdirectory's Jamfile.

	# We use SubDir to get there, in case the included Jamfile
	# either doesn't have its own SubDir (naughty) or is a subtree
	# with its own TOP.
	if ! $($(<[1]))
	{
	    Exit SubInclude $(<[1]) without prior SubDir $(<[1]) ;
	}

	local jamfile ;
	if $(>)
	{
		jamfile = $(>:S=.jam) ;
	}
	else
	{
		jamfile = $(JAMFILE) ;
	}

	local include_marker = included_$(<:J=_)_$(jamfile) ;
	if $($(include_marker))
	{
		return ;
	}
	$(include_marker) = true ;

	local saveTokens = $(ALL_SUBDIR_TOKENS) ;
	local saveCurrentJamfile = $(CURRENT_JAMFILE) ;
	SubDir $(<) ;

	CURRENT_JAMFILE = $(jamfile:D=$(SUBDIR)) ;
	include $(CURRENT_JAMFILE) ;

	if $(saveTokens)
	{
		SubDir $(saveTokens) ;
		CURRENT_JAMFILE = $(saveCurrentJamfile) ;
	}
}

rule SubRules
{
	# SubRules TOP d1 ... : Other-TOP ;
	#
	# Read another tree's Jamrules, by giving it's path according
	# to this tree and it's own name.

	if ! $($(<[1]))
	{
	    Exit SubRules $(<[1]) without prior SubDir $(<[1]) ;
	}

	SubDir $(<) ;
	SubDir $(>) ;
}

#
# Utility rules; no side effects on these
#

rule FGrist
{
	return $(<:J=!) ;

}

rule FGristFiles
{
	return $(<:G=$(SOURCE_GRIST:E)) ;
}

rule FReverse
{
	# FReverse a1 a2 a3 ... ;
	# return ... a3 a2 a1 ;

	if $(1) { return [ FReverse $(1[2-]) ] $(1[1]) ; }
}

rule FSubDir
{
	# If $(>) is the path to the current directory, compute the
	# path (using ../../ etc) back to that root directory.
	# Sets result in $(<)

	if ! $(<[1])
	{
	    return $(DOT) ;
	}
	else
	{
	    local _i _d ;

	    _d = $(DOTDOT) ;

	    for _i in $(<[2-])
	    {
		_d = $(_d:R=$(DOTDOT)) ;
	    }

	    return $(_d) ;
	}
}

rule FStripCommon
{
	# FStripCommon v1 : v2 ;

	# Strip common initial elements of variables v1 and v2.
	# Modifies the variable values themselves.

	if $($(<)[1]) && $($(<)[1]) = $($(>)[1])
	{
	    $(<) = $($(<)[2-]) ;
	    $(>) = $($(>)[2-]) ;
	    FStripCommon $(<) : $(>) ;
	}
}

rule FRelPath
{
	local _l _r ;

	# first strip off common parts

	_l = $(<) ;
	_r = $(>) ;

	FStripCommon _l : _r ;

	# now make path to root and path down

	_l = [ FSubDir $(_l) ] ;
	_r = [ FDirName $(_r) ] ;

	# Concatenate and save

	# XXX This should be better

	if $(_r) = $(DOT) {
	    return $(_l) ;
	} else {
	    return $(_r:R=$(_l)) ;
	}
}

#
# Operating system specific utility rules
# First, the (generic) UNIX versions
#

rule FQuote { return \\\"$(<)\\\" ; }
rule FDefines { return -D$(<) ; }
rule FIncludes { return -I$(<) ; }
rule FLibraryPaths { return -L$(<) ; }

rule FDirName
{
	# Turn individual elements in $(<) into a usable path.

	local _i ;
	local _s = $(DOT) ;

	for _i in $(<)
	{
	    _s = $(_i:R=$(_s)) ;
	}

	return $(_s) ;
}

if $(MSVCNT)
{
	rule FDefines { return /D$(<) ; }
	rule FIncludes { return /I"\"$(<)\"" ; }
	rule FLibraryPaths { return \"/LIBPATH:$(<)\" ; }
}

#
# Actions
#

#
# First the defaults
#

actions updated together piecemeal Archive
{
	$(AR) $(LIBFLAGS) $(<) $(>)
}

actions piecemeal together existing Clean
{
	$(RM) $(>)
}

if $(NT)
{
	actions piecemeal together existing Clean
	{
	$(RM) "$(>:\\)"
	}
}

actions Link
{
	"$(LINK)" $(LINKFLAGS) -o $(<[1]) $(UNDEFS) $(>) $(NEEDLIBS:T) $(LINKLIBS)
}

actions quietly MkDir1
{
	$(MKDIR) $(<)
}

if $(NT)
{
	actions quietly MkDir1
	{
		if not exist "$(<:\\)" $(MKDIR) "$(<:\\)"
	}
}

actions together Ranlib
{
	$(RANLIB) $(<)
}

actions quietly updated piecemeal together RmTemps
{
	$(RM) $(>)
}

if $(NT)
{
	actions quietly updated piecemeal together RmTemps
	{
	$(RM) "$(>:\\)"
	}
}

#
# NOARUPDATE - can't update an archive
#

if $(NOARUPDATE)
{
	actions Archive
	{
	$(AR) $(LIBFLAGS) $(<) $(>)
	}
}

#
# UNIX specific actions
#

if $(UNIX)
{
}

#
# NT specific actions
#

if $(NT) && $(MSVCNT)
{
	actions together piecemeal Archive
	{
	if exist $(<) set _$(<:B)_=$(<)
	$(AR) $(LIBFLAGS) /out:$(<) %_$(<:B)_% $(>)
	}

	actions piecemeal together existing Clean
	{
		$(RM) "$(>:\\)"
	}

	actions response LinkDebug
	{
	set PATH=%PATH%;$(MSVCBIN);$(MSVCNT_PATH);$(MSSDK)/bin
	set INCLUDE=$(MSSDK)/include
	"$(LINK:\\)" /nologo /out:$(<[1]) $(UNDEFS) @@($(LINKFLAGS) $(>) $(NEEDLIBS:T) "$(LINKLIBS)")
	if exist $(MANIFEST).intermediate.manifest "$(MT:\\)" -nologo -notify_update -manifest $(MANIFEST).intermediate.manifest -out:$(MANIFEST).embed.manifest &
	if "%ERRORLEVEL%" == "1090650113" echo $(MANIFEST_TYPE) 24 "$(MANIFEST).embed.manifest" > "$(MANIFEST).embed.rc" &
	"$(RC:\\)" /fo $(MANIFEST).embed.res $(MANIFEST).embed.rc &
	"$(LINK:\\)" /nologo /out:$(<[1]) $(UNDEFS) @@($(LINKFLAGS) $(>) $(NEEDLIBS:T) "$(LINKLIBS)")
	}

	actions response LinkNoManifest
	{
	set PATH=%PATH%;$(MSVCBIN);$(MSVCNT_PATH);$(MSSDK)/bin
	set INCLUDE=$(MSSDK)/include
	"$(LINK:\\)" /nologo /out:$(<[1]) $(UNDEFS) @@($(LINKFLAGS) $(>) $(NEEDLIBS:T) "$(LINKLIBS)")
	}

	actions response Link
	{
	set PATH=%PATH%;$(MSVCBIN);$(MSVCNT_PATH);$(MSSDK)/bin
	set INCLUDE=$(MSSDK)/include
	"$(LINK:\\)" /nologo /out:$(<[1]) $(UNDEFS) @@($(LINKFLAGS) $(>) $(NEEDLIBS:T) "$(LINKLIBS)")
	"$(MT:\\)" -nologo -manifest $(MANIFEST).intermediate.manifest -outputresource:$(<[1]);$(MANIFEST_TYPE)
	}

	actions RegSvr32
	{
	regsvr32 /s /c "$(1)"
	}

	actions existing UnRegSvr32
	{
	regsvr32 /s /u "$(2)"
	}

}

if $(WIN98)
{
    actions existing Clean
    {
	del $(>)
    }
}

########################################################################
# The original MultiCppCompile rule was provided by Alen Ladavac.
########################################################################

# Used to group files from a list by some bound variable.
# Files with first value of the variable are returned as results, and removed from the input list.
# NOTE: _filelist and _varname are passed by reference!
# [ GroupByVar1 _filelist : _varname [: maxPerGroup] ]
rule GroupByVar1
{
	# get the actual filelist
	local _all = $($(1)) ;

	# get value of the variable on the first file
	local _var1 ;
	on $(_all[1]) _var1 = $($(2)) ;

	local _group1 = ;
	local _rest = ;
	local _f ;

	if $(3)
	{
		local _count = 0 ;
		local _done ;
		for _f in $(_all) {
			local _var ;
			on $(_f) _var = $($(2)) ;
			if ! $(_done) && ( $(_var) in $(_var1) ) && ( $(_var1) in $(_var) )  {
				_group1 += $(_f) ;
				_count = [ Math $(_count) + 1 ] ;
				if $(_count) = $(3)
				{
					_done = true ;
				}
			} else {
				_rest += $(_f) ;
			}
		}
		$(1) = $(_rest) ;
		return $(_group1) ;
	}

	for _f in $(_all) {
		local _var ;
		on $(_f) _var = $($(2)) ;
		if ( $(_var) in $(_var1) ) && ( $(_var1) in $(_var) )  {
			_group1 += $(_f) ;
		} else {
			_rest += $(_f) ;
		}
	}
	$(1) = $(_rest) ;
	return $(_group1) ;
}


rule BatchCompileGroupSize TARGET : SIZE
{
	BATCH_COMPILE_GROUP_SIZE on $(TARGET) = $(SIZE) ;
}


#---------------------------------------------------------------------
# OBJECTS = MultiCppCompile $(sources) ;
#
#   This rule will compile $(sources), and will return  the result objects.
#
#---------------------------------------------------------------------
# Set this if you want object files to be put in subdirs matching dir hierarchy of source files.
# Otherwise, all object files are put in one flat directory per project.
rule CppCompileOptions OPTIONS
{
	if outputastree in $(OPTIONS)
	{
		__MultiCppCompile_OutputAsTree = 1 ;
	}
}


__MultiCppCompile_OutputAsTree = 0 ;

rule MultiCppCompile TARGET : SOURCES
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;

	local grist = $(TARGET) ;

	#
	# Pass 1: Bind final flags to each file
	#

	local _postmflags ;

	if $(MSVCNT)
	{
		switch $(COMPILER)
		{
			case vc6 	: _VCPDB = vc60 ;
			case vs2002 : _VCPDB = vc70 ;
			case vs2003 : _VCPDB = vc70 ;
			case vs2005 : _VCPDB = vc80 ;
			case vs2008 : _VCPDB = vc90 ;
		}

		local vcidb = $(_VCPDB:G=$(grist):S=.idb) ;
		_VCPDB = $(_VCPDB:G=$(grist):S=.pdb) ;
		MakeLocate $(vcidb) $(_VCPDB) : $(LOCATE_TARGET) ;

		Clean clean:$(TARGET) : $(_VCPDB) $(vcidb) ;

		if $(__MultiCppCompile_OutputAsTree) = 0 {
			local combinedLocateTarget = [ FDirName $(LOCATE_TARGET) ] ;
			_postmflags = "/c \"/Fo$(combinedLocateTarget:\\)\\\\\" \"/Fd$(_VCPDB:T)\"" ;
		}
	}

	local ALL_TYPES =
			$(PLATFORM).$(CONFIG)
			*.$(CONFIG)
			$(PLATFORM).*
			*.*
	;

	local postHDRS ;
	on $(TARGET) postHDRS += $(HDRS.$(ALL_TYPES)) ;
	on * postHDRS += $(HDRS.$(ALL_TYPES)) ;
	postHDRS +=
			$(SUBDIRHDRS)
			$(STDHDRS)
	;

	local postREFERENCEDIRECTORIES ;
	if $(MSVCNT)
	{
		on $(TARGET) postREFERENCEDIRECTORIES += $(REFERENCEDIRECTORIES.$(ALL_TYPES)) ;
		on * postREFERENCEDIRECTORIES += $(REFERENCEDIRECTORIES.$(ALL_TYPES)) ;
		postREFERENCEDIRECTORIES = /I\"$(postREFERENCEDIRECTORIES)\" /AI\"$(postREFERENCEDIRECTORIES)\" ;
	}

	local preDEFINES ;
	on * preDEFINES += $(DEFINES.$(ALL_TYPES)) ;
	on $(TARGET) preDEFINES += $(DEFINES.$(ALL_TYPES)) ;
	preDEFINES = [ FDefines $(preDEFINES) ] ;

	local preCCFLAGS ;
	on * preCCFLAGS += $(CCFLAGS.$(ALL_TYPES)) ;
	on $(TARGET) preCCFLAGS += $(CCFLAGS.$(ALL_TYPES)) ;

	local preC++FLAGS ;
	on * preC++FLAGS += $(C++FLAGS.$(ALL_TYPES)) ;
	on $(TARGET) preC++FLAGS += $(C++FLAGS.$(ALL_TYPES)) ;

	# start with empty list of all generated objects
	local _allobjs = ;

	# for each file
	local _src ;
	local newsrcs ;
	local extraSources ;
	if $(MSVCNT)
	{
		extraSources = $(SOURCES:I=\\$(SUFRES)) ;
	}
	local sources = $(SOURCES:I=\\.cpp$:I=\\.c$:I=\\.cxx$I=\\$(SUFOBJ)$:G=$(grist)) ;
	sources += $(extraSources) ;
#	local objSources = $(SOURCES:I=\\$(SUFOBJ)$:I=\\$(SUFRES):G=$(grist)) ;
#	local sources = $(SOURCES:G=$(grist)) ;

	# source needs to be scanned for header dependencies
	HDRRULE on $(sources) = HdrRule ;
	HDRSCAN on $(sources) = $(HDRPATTERN) ;
	HDRGRIST on $(sources) = $(grist) ;

	if $(__MultiCppCompile_OutputAsTree) = 0 {
		MakeLocate $(sources:S=$(SUFOBJ):D=) : $(LOCATE_TARGET) ;
	}
	SEARCH on $(sources) = $(SEARCH_SOURCE) ;

#	MakeLocate $(objSources:S=$(SUFOBJ):D=) : $(LOCATE_TARGET) ;
#	SEARCH on $(objSources) = $(SEARCH_SOURCE) ;

#	for _src in $(_objSources) {
#		on $(_src) if $(EXCLUDED_FROM_BUILD) = true {
#			continue ;
#		}
#		_allobjs += $(_src) ;
#	}

	for _src in $(sources) {
		on $(_src) if $(EXCLUDED_FROM_BUILD) = true {
			continue ;
		}
		local ext = $(_src:S) ;
		if $(ext) in $(SUFOBJ) $(SUFRES) {
			_allobjs += $(_src) ;
			continue ;
		}

		local _obj ;
		if $(__MultiCppCompile_OutputAsTree) != 0 {
			_obj = [ Subst $(_src:S=$(SUFOBJ)) : %.%. : __ ] ;
			_obj = [ Subst $(_obj) : \: : -- ] ;
			local _objdir = $(_obj:DR=$(LOCATE_TARGET)) ;
			MakeLocate $(_obj) : $(_objdir) ;
			BINDING on $(_obj) = $(_obj:BS) ;
			_postmflags = "/c \"/Fo$(_objdir:\\)\\\\\" \"/Fd$(_VCPDB:T)\"" ;
		} else {
			_obj = $(_src:S=$(SUFOBJ):D=) ;
		}

		local _hdrs = $(SEARCH_SOURCE) ;
		on $(_obj) _hdrs += $(HDRS.$(ALL_TYPES)) ;
		_hdrs += $(postHDRS) ;

		HDRSEARCH on $(_src) = $(_hdrs) ;

		# Rest
		Depends $(_obj) : $(_src) ;

		local _flags ;
		switch $(ext) {
			case .c :
				CC on $(_obj) = $(CC) ;

				_flags = $(preCCFLAGS) ;
				on $(_obj) _flags += $(CCFLAGS.$(ALL_TYPES)) ;
				_flags += $(SUBDIRCCFLAGS) ;

			case .cpp :
				C++ on $(_obj) = $(C++) ;

				_flags = $(preC++FLAGS) ;
				on $(_obj) _flags += $(C++FLAGS.$(ALL_TYPES)) ;
				_flags += $(SUBDIRC++FLAGS) ;

			case .cxx :
				C++ on $(_obj) = $(C++) ;

				_flags = $(preC++FLAGS) ;
				on $(_obj) _flags += $(C++FLAGS.$(ALL_TYPES)) ;
				_flags += $(SUBDIRC++FLAGS) ;
		}

		_flags += [ FIncludes $(_hdrs) . ] ;

		_flags += $(preDEFINES) ;
		on $(_obj) _flags += [ FDefines $(DEFINES.$(ALL_TYPES)) ] ;

		# now that general flags on the file are determined

		if $(MSVCNT) {
			_flags += $(postREFERENCEDIRECTORIES) ;

			# if the source should create pch
			local _pch ;
			on $(_src) _pch = $(PCH) ;
			if $(_pch) {
				local _nopch ;
				on $(_src) _nopch = $(NOPCH) ;
				if $(_pch[3]) {
					# add extra flags to enable pch creation
					local _pchFilename = $(_pch[1]).pch ;
					local _pchDiskFilename = [ FDirName $(LOCATE_TARGET) $(_pchFilename:BS) ] ;
					_flags += /Fp$(_pchDiskFilename:\\) ;  # pch file
					_flags += /Yc$(_pch[2]) ;  # h file
					# mark that it will be created by compilation through srcref
					_pchFilename = $(_pchFilename:G=$(grist)) ;
					BINDING on $(_pchFilename) = $(_pchFilename:BS) ;
					MakeLocate $(_pchFilename) : $(LOCATE_TARGET) ;
					Depends $(_pchFilename) : $(_src) ;
					Clean clean:$(TARGET) : $(_pchFilename) ;

				# if the source should use pch
				} else if $(_pch[2]) && ! $(_nopch) {
					# add extra flags to enable pch loading
					local _pchFilename = $(_pch[1]).pch ;
					local _pchDiskFilename = [ FDirName $(LOCATE_TARGET) $(_pchFilename:BS) ] ;
					_flags += /Fp$(_pchDiskFilename:\\) ;  # pch file
					_flags += /Yu$(_pch[2]) ;  # h file
					# mark that compilation will depend on it
					_pchFilename = $(_pchFilename:G=$(grist)) ;
					Includes $(_src) : $(_pchFilename) ;
				}
			}

			# bind flags, defines and includes to the target
			_flags += $(_postmflags) ;
			MFLAGS on $(_src) = $(_flags) ;
			UseCommandLine $(_obj) : $(_flags) ;
		}
		else if $(COMPILER) in mingw gcc
		{
			MFLAGS on $(_src) = $(_flags) "-c -o \"$(_obj:T)\"" ;
			UseCommandLine $(_obj) : $(_flags) ;
		}

		newsrcs += $(_src) ;
	}

	#
	# Pass 2: Compile in batches, grouped by flags that were bound in previous pass
	#

	local batchCompileGroupSize ;
	on $(TARGET) batchCompileGroupSize = $(BATCH_COMPILE_GROUP_SIZE) ;
	if ! $(batchCompileGroupSize)
	{
		on * batchCompileGroupSize = $(BATCH_COMPILE_GROUP_SIZE) ;
	}

	# for each batch, grouped by final flags
	while $(newsrcs) {
		_sources = [ GroupByVar1 newsrcs : MFLAGS : $(batchCompileGroupSize) ] ;

		# start with empty lists of objects for this batch
		local objects ;
		# for each source in this batch
		local _obj ;
		if $(__MultiCppCompile_OutputAsTree) != 0 {
			local renamed = [ Subst $(_sources:S=$(SUFOBJ)) : %.%. : __ ] ;
			renamed = [ Subst $(renamed) : \: : -- ] ;
			objects += $(renamed) ;
		} else {
			objects += $(_sources:S=$(SUFOBJ):D=) ;
		}

		# collect produced objects (note that this is before adding the pch,
		# because we don't want to use it in linking)
		_allobjs += $(objects) ;

		# if this batch will also create a pch
		local _pch1 ;
		on $(_sources[1]) _pch1 = $(PCH) ;
		if $(MSVCNT) {
			if $(_pch1[3]) {
				local _pchFilename = $(_pch1[1]).pch ;
				_pchFilename = $(_pchFilename:G=$(grist)) ;
				Depends $(objects) : $(_pchFilename) ;
				# add that pch as output
				objects += $(_pchFilename) ;
			}
		}

		# mark all objects (and pch) for cleaning
		Clean clean:$(TARGET) : $(objects) ;

		MFLAGS on $(objects) = [ on $(_sources[1]) Var MFLAGS ] ;
		if $(MSVCNT) {
			SEMAPHORE on $(objects) = $(_VCPDB) ;
		}
		batched_C++ $(objects) : $(_sources) ;
	}

	# return all produced objects
	return $(_allobjs) ;
}


if $(MSVCNT)
{
	actions updated response batched_C++
	{
		PATH=$(MSVCNT_PATH);%PATH%
		SET INCLUDE=$(STDHDRS:\\J=;)
		"$(C++:\\)" /nologo @@($(>)) $(MFLAGS)
	}

	actions together response Archive
	{
	PATH=%PATH%;$(MSVCNT_PATH)
	"$(AR)" /nologo $(LIBFLAGS) /out:$(<) @@($(>:\\))
	}
}

if $(COMPILER) in mingw gcc
{
	actions updated response batched_C++
	{
		$(CC) -c $(MFLAGS) $(>)
	}
}

########################################################################
########################################################################

rule Lump PARENT : SOURCES_VARIABLE_NAME : LUMP_NAME : PCH_HEADER :
		PCH_HEADER_FILENAME : LUMP_EXT : EXTRA_INCLUDE_PATHS
{
	if $(LUMP) = 0
	{
		return ;
	}

	PARENT = [ _retrieveActiveTargetName $(PARENT) ] ;
	local grist = $(PARENT) ;

	LUMP_EXT ?= cpp ;

	local contents = "// This lump file is a generated file.  Do not modify.$(NEWLINE)" ;
	local line ;
	local PCH_SOURCE_FILENAME ;
	if $(PCH_HEADER)
	{
		PCH_SOURCE_FILENAME = $(PCH_HEADER).$(LUMP_EXT) ;
		PCH_HEADER_FILENAME ?= $(PCH_HEADER).h ;
		line = "#include \"$(PCH_HEADER_FILENAME)\"$(NEWLINE)" ;
		contents = $(contents)$(line) ;
	}

	local file ;
	for file in $($(SOURCES_VARIABLE_NAME))
	{
		if [ on $(file:G=$(grist)) Var EXCLUDED_FROM_BUILD ] = true {
			continue ;
		}
		if $(file:S) in .c .cpp .cxx  &&  $(file) != $(PCH_SOURCE_FILENAME)
		{
			line = "#include \"$(file)\"$(NEWLINE)" ;
			contents = $(contents)$(line) ;
		}
	}

	contents = $(contents)$(NEWLINE) ;

	local gristedFileName = @(!$(LUMP_NAME)!.$(LUMP_EXT):G=$(grist)) ;
	MakeLocate $(gristedFileName) : $(LOCATE_SOURCE) ;
	Clean clean:$(PARENT) : $(gristedFileName) ;

	$(SOURCES_VARIABLE_NAME) = $(PCH_SOURCE_FILENAME) $(gristedFileName) ;

	local subdir = $(SUBDIR[1]:R=$(CWD)) ;
	ObjectIncludeDirectories $(gristedFileName) : $(subdir) ;
	if $(EXTRA_INCLUDE_PATHS)
	{
		ObjectIncludeDirectories $(gristedFileName) : $(EXTRA_INCLUDE_PATHS) ;
	}

	if [ MD5 $(contents) ] != [ MD5File $(gristedFileName) ]
	{
		CONTENTS on $(gristedFileName) = $(contents) ;
		Always $(gristedFileName) ;
		MakeLump $(gristedFileName) ;
	}
}

actions MakeLump
{
	^^($(1)|$(CONTENTS))
}


########################################################################
########################################################################

rule _retrieveActiveTargetName TARGETS
{
	return $(TARGETS:E=$(ACTIVE_PROJECT:E="")) ;
}

rule _retrieveVar VARIABLE : TARGET : THE_CONFIG : THE_PLATFORM
{
	THE_CONFIG ?= $(CONFIG) ;
	THE_PLATFORM ?= $(PLATFORM) ;

	# Fastest
	on $(TARGET) return $($(VARIABLE).$(THE_PLATFORM).$(THE_CONFIG))
			$($(VARIABLE).*.$(THE_CONFIG))
			$($(VARIABLE).$(THE_PLATFORM).*)
			$($(VARIABLE).*.*) ;

#	return
#		[ on $(TARGET) MultiVar
#				$(VARIABLE).$(THE_PLATFORM).$(THE_CONFIG)
#				$(VARIABLE).*.$(THE_CONFIG)
#				$(VARIABLE).$(THE_PLATFORM).*
#				$(VARIABLE).*.* ] ;

#	return
#		[ on $(TARGET) Var $(VARIABLE).$(THE_PLATFORM).$(THE_CONFIG) ]
#		[ on $(TARGET) Var $(VARIABLE).*.$(THE_CONFIG) ]
#		[ on $(TARGET) Var $(VARIABLE).$(THE_PLATFORM).* ]
#		[ on $(TARGET) Var $(VARIABLE).*.* ] ;
}


rule _retrieveOutputPath TARGET : THE_CONFIG : THE_PLATFORM
{
	THE_CONFIG ?= $(CONFIG) ;
	THE_PLATFORM ?= $(PLATFORM) ;
	local outputPath = [ on $(TARGET) SearchVar
			LOCATE.$(THE_PLATFORM).$(THE_CONFIG)
			LOCATE.*.$(THE_CONFIG)
			LOCATE.$(THE_PLATFORM).*
			LOCATE.*.* ] ;
	if ! $(outputPath)
	{
		outputPath = [ on * SearchVar
				LOCATE.$(THE_PLATFORM).$(THE_CONFIG)
				LOCATE.*.$(THE_CONFIG)
				LOCATE.$(THE_PLATFORM).*
				LOCATE.*.* : $(LOCATE_TARGET) ] ;
	}
	return $(outputPath) ;
}


rule _retrieveOutputName TARGET : SUFFIX_NAME : THE_CONFIG : THE_PLATFORM
{
	THE_CONFIG ?= $(CONFIG) ;
	THE_PLATFORM ?= $(PLATFORM) ;
	local target = [ on $(TARGET) SearchVar
			OUTPUTNAME.$(THE_PLATFORM).$(THE_CONFIG)
			OUTPUTNAME.*.$(THE_CONFIG)
			OUTPUTNAME.$(THE_PLATFORM).*
			OUTPUTNAME.*.*
			: $(TARGET) ] ;

	local presuffix = [ on $(TARGET) SearchVar
			OUTPUTPOSTFIX.$(THE_PLATFORM).$(THE_CONFIG)
			OUTPUTPOSTFIX.*.$(THE_CONFIG)
			OUTPUTPOSTFIX.$(THE_PLATFORM).*
			OUTPUTPOSTFIX.*.* ] ;
	presuffix ?= [ on * SearchVar
			OUTPUTPOSTFIX.$(THE_PLATFORM).$(THE_CONFIG)
			OUTPUTPOSTFIX.*.$(THE_CONFIG)
			OUTPUTPOSTFIX.$(THE_PLATFORM).*
			OUTPUTPOSTFIX.*.* ] ;
	presuffix ?= .$(THE_CONFIG) ;
	if $(presuffix) = *off*
	{
		presuffix = ;
	}

	local suffix = [ on $(TARGET) SearchVar
			OUTPUTSUFFIX.$(THE_PLATFORM).$(THE_CONFIG)
			OUTPUTSUFFIX.*.$(THE_CONFIG)
			OUTPUTSUFFIX.$(THE_PLATFORM).*
			OUTPUTSUFFIX.*.*
			$(SUFFIX_NAME).$(THE_PLATFORM)
			$(SUFFIX_NAME).*
			$(SUFFIX_NAME) ] ;

	return $(target)$(presuffix:E=)$(suffix:E=) ;
}


########################################################################
########################################################################

actions quietly WriteFile
{
	^^($(1)|$(CONTENTS))
}

rule _writeManifest TARGET : _t : MANIFEST_TYPE
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;

	local tempIntermediateManifest = @($(_t).intermediate.manifest:G=$(grist)) ;
	MakeLocate $(tempIntermediateManifest) : $(LOCATE_TARGET) ;
	Clean clean:$(TARGET) : $(tempIntermediateManifest) ;

	if $(CONFIG) = debug
	{
		local tempEmbeddedManifest = @($(_t).embed.manifest:G=$(grist)) ;
		MakeLocate $(tempEmbeddedManifest) : $(LOCATE_TARGET) ;
		CONTENTS on $(tempEmbeddedManifest) =
"<?xml version='1.0' encoding='UTF-8' standalone='yes'?>
<assembly xmlns='urn:schemas-microsoft-com:asm.v1' manifestVersion='1.0'>
</assembly>
" ;
		WriteFile $(tempEmbeddedManifest) ;
		Clean clean:$(TARGET) : $(tempEmbeddedManifest) ;

		local tempEmbeddedRc = @($(_t).embed.rc:G=$(grist)) ;
		Depends $(tempEmbeddedRc) : $(tempEmbeddedManifest) ;
		MakeLocate $(tempEmbeddedRc) : $(LOCATE_TARGET) ;
		CONTENTS on $(tempEmbeddedRc) =
			"$(MANIFEST_TYPE) /* CREATEPROCESS_MANIFEST_RESOURCE_ID */ 24 /* RT_MANIFEST */ \"$(LOCATE_TARGET)/$(_t:G=).embed.manifest\"" ;
		WriteFile $(tempEmbeddedRc) ;
		Clean clean:$(TARGET) : $(tempEmbeddedRc) ;
		Depends $(tempEmbeddedRc) : $(tempEmbeddedManifest) ;

		local tempEmbeddedRes = [ ResourceCompiler $(TARGET) : $(tempEmbeddedRc) : quiet ] ;
		_s += $(tempEmbeddedRes) ;

		Depends $(_t) : $(tempIntermediateManifest) $(tempEmbeddedRes) ;
	}

	MANIFEST_TYPE on $(_t) = $(MANIFEST_TYPE) ;
}


rule _linkManifest _t
{
	MANIFEST on $(_t) = "$(LOCATE_TARGET)/$(_t[1]:G=)" ;
}


########################################################################
########################################################################

rule Application TARGET : SOURCES : OPTIONS
{
	local objects = [ MultiCppCompile $(TARGET) : $(SOURCES) : $(TARGET) ] ;
	ApplicationFromObjects $(TARGET) : $(objects) : $(OPTIONS) ;
	ACTIVE_PROJECT = "" ;
}


rule ApplicationFromObjects TARGET : OBJECTS : OPTIONS
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	local _s = $(OBJECTS:G=$(grist)) ;
	local _t = [ _retrieveOutputName $(TARGET) : SUFEXE ] ;
	_t = $(_t:G=$(grist)) ;

	local outputPath = [ _retrieveOutputPath $(TARGET) ] ;

	local _linkTargets = $(_t) ;

	Depends all : $(TARGET) ;
	Depends $(TARGET) : $(_linkTargets) ;
	NotFile $(TARGET) ;
	Depends $(_linkTargets) : $(_s) ;
	MakeLocate $(_linkTargets) : $(outputPath) ;

	Depends clean : clean:$(TARGET) ;
	NotFile clean:$(TARGET) ;
	Always clean:$(TARGET) ;
	Depends allclean : allclean:$(TARGET) ;
	NotFile allclean:$(TARGET) ;
	Always allclean:$(TARGET) ;
	Depends allclean:$(TARGET) : clean:$(TARGET) ;
	Clean clean:$(TARGET) : $(_linkTargets) ;

	local linkFlags =
		[ FLibraryPaths [ _retrieveVar LINKDIRECTORIES : $(TARGET) : $(CONFIG) : $(PLATFORM) ] ]
		[ FLibraryPaths [ _retrieveVar LINKDIRECTORIES : * : $(CONFIG) : $(PLATFORM) ] ]
		[ _retrieveVar LINKFLAGS : $(TARGET) : $(CONFIG) : $(PLATFORM) ]
		[ _retrieveVar LINKFLAGS : * : $(CONFIG) : $(PLATFORM) ] ;

	if $(COMPILER) in vc6 vs2003 vs2005 vs2008 {
		if windows in $(OPTIONS) {
			linkFlags += /SUBSYSTEM:WINDOWS ;
		} else {
			linkFlags += /SUBSYSTEM:CONSOLE ;
		}
	}

	local linkLibs =
		[ _retrieveVar LINKLIBS : $(TARGET) : $(CONFIG) : $(PLATFORM) ]
		[ _retrieveVar LINKLIBS : * : $(CONFIG) : $(PLATFORM) ] ;

	local needLibs =
		[ _retrieveVar NEEDLIBS : $(TARGET) : $(CONFIG) : $(PLATFORM) ]
		[ _retrieveVar NEEDLIBS : * : $(CONFIG) : $(PLATFORM) ] ;

	NEEDLIBS on $(_linkTargets) = $(needLibs) ;
	Depends $(_linkTargets) : $(needLibs) ;

	if $(MSVCNT) {
	    # Clean the .pdb (etc) files.
		local sufs = .pdb .map .lib .exp .ilk ;
	    local zap = $(_t:S=$(sufs)) ;
	    MakeLocate $(zap) : $(outputPath) ;
	    Clean clean:$(TARGET) : $(zap) ;

	    Depends $(zap) : $(_linkTargets) ;

		if $(COMPILER) in vs2005 vs2008  &&  ! ( nomanifest in $(OPTIONS) )
		{
			_writeManifest $(TARGET) : $(_t) : 1 ;
			_linkManifest $(_t) ;
			linkFlags += /MANIFEST /MANIFESTFILE:$(LOCATE_TARGET)/$(_t:G=).intermediate.manifest ;
		}
	}

	LINKFLAGS on $(_linkTargets) = $(linkFlags) ;
	LINKLIBS on $(_linkTargets) = $(linkLibs) ;

	UseCommandLine $(_linkTargets) : $(linkFlags) $(linkLibs) $(needLibs) $(_s) ;

	Link $(_linkTargets) : $(_s) ;
	Includes $(_s) : $(_s) ;

	LINK_TARGET on $(TARGET) = $(_linkTargets) ;
}


########################################################################
########################################################################

rule Library TARGET : SOURCES : OPTIONS
{
	local objects = [ MultiCppCompile $(TARGET) : $(SOURCES) : $(TARGET) ] ;
	if shared in $(OPTIONS)  ||  module in $(OPTIONS)
	{
		SharedLibraryFromObjects $(TARGET) : $(objects) : $(OPTIONS) ;
	}
	else
	{
		LibraryFromObjects $(TARGET) : $(objects) ;
	}
	ACTIVE_PROJECT = ;
}


rule LibraryFromObjects TARGET : OBJECTS
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	local _s = $(OBJECTS:G=$(grist)) ;
	local _l = $(TARGET:G=$(TARGET))$(SUFLIB) ;
	BINDING on $(_l) = [ _retrieveOutputName $(TARGET) : SUFLIB ] ;

	# library depends on its member objects

    Depends all : $(TARGET) ;
	if $(KEEPOBJS)
	{
		Depends $(TARGET) : $(_s) ;
	}
	else
	{
		Depends $(TARGET) : $(_l) ;
	}

	NotFile $(TARGET) ;

	# Set LOCATE for the library and its contents.  The bound
	# value shows up as $(NEEDLIBS) on the Link actions.
	# For compatibility, we only do this if the library doesn't
	# already have a path.

	if ! $(_l:D)
	{
		local outputPath = [ _retrieveOutputPath $(TARGET) ] ;
	    MakeLocate $(_l) $(_l)($(_s:BS)) : $(outputPath) ;
	}

	if $(NOARSCAN)
	{
	    # If we can't scan the library to timestamp its contents,
	    # we have to just make the library depend directly on the
	    # on-disk object files.

	    Depends $(_l) : $(_s) ;
	}
	else
	{
	    # If we can scan the library, we make the library depend
	    # on its members and each member depend on the on-disk
	    # object file.

	    Depends $(_l) : $(_l)($(_s:BS)) ;

		local _i ;
	    for _i in $(_s)
	    {
			Depends $(_l)($(_i:BS)) : $(_i) ;
	    }
	}

	Depends clean : clean:$(TARGET) ;
	NotFile clean:$(TARGET) ;
	Always clean:$(TARGET) ;
	Depends allclean : allclean:$(TARGET) ;
	NotFile allclean:$(TARGET) ;
	Always allclean:$(TARGET) ;
	Depends allclean:$(TARGET) : clean:$(TARGET) ;
	Clean clean:$(TARGET) : $(_l) ;

	if $(CRELIB) { CreLib $(_l) : $(_s[1]) ; }

	UseCommandLine $(_linkTargets) : $(_s) ;

	local libFlags =
		[ _retrieveVar LIBFLAGS : $(TARGET) : $(CONFIG) : $(PLATFORM) ]
		[ _retrieveVar LIBFLAGS : * : $(CONFIG) : $(PLATFORM) ] ;
	LIBFLAGS on $(_l) = $(libFlags) ;

	UseCommandLine $(_l) : $(libFlags) ;

	Archive $(_l) : $(_s) ;

	if $(RANLIB) { Ranlib $(_l) ; }

	# If we can't scan the library, we have to leave the .o's around.

	if ! ( $(NOARSCAN) || $(NOARUPDATE) ) { RmTemps $(_l) : $(_s) ; }
}


rule SharedLibraryFromObjects TARGET : OBJECTS : OPTIONS
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	local _s = $(OBJECTS:G=$(grist)) ;

	local suffixName = SUFSHAREDLIB ;
	if module in $(OPTIONS) {
		suffixName = SUFMODULE ;
	}

	local _t = [ _retrieveOutputName $(TARGET) : $(suffixName) ] ;
	_t = $(_t:G=$(grist)) ;

	local outputPath = [ _retrieveOutputPath $(TARGET) ] ;

	local _linkTargets = $(_t) ;

	if ! ( noexportlib in $(OPTIONS) ) {
		local _tlib = @($(TARGET)$(SUFLIB):G=$(grist)) ;

		if $(COMPILER) in vs2003 vs2005 vs2008 {
			BINDING on $(_tlib) = [ _retrieveOutputName $(TARGET) : SUFLIB ] ;
			MightNotUpdate $(_tlib) ;
			_linkTargets += $(_tlib) ;
		}
		else if $(COMPILER) in mingw gcc {
#			BINDING on $(_tlib) = [ _retrieveOutputName $(TARGET) : SUFLIB ] ;
			BINDING on $(_tlib) = $(_t) ;
			NotFile $(_tlib) ;		# Turn this off for export libraries.
			_linkTargets += $(_tlib) ;

#			LinkFlags $(TARGET) : -Wl,--out-implib,$(_tlib:T) ;
		}
#		else if $(UNIX)
#		{
#			Exit SharedLibraryFromObjects not implemented. ;
#		}
	}

	Depends all : $(TARGET) ;
	Depends $(TARGET) : $(_linkTargets) ;
	NotFile $(TARGET) ;
	Depends $(_linkTargets) : $(_s) ;
	MakeLocate $(_linkTargets) : $(outputPath) ;

	local regserver ;
	if regserver in $(OPTIONS)  &&  $(COMPILER) in vc6 vs2003 vs2005 vs2008 {
		regserver = true ;

		local unregserver = clean:$(TARGET):unregserver ;
		Depends clean:$(TARGET) : $(unregserver) ;
		NotFile $(unregserver) ;
		Always $(unregserver) ;
		UnRegSvr32 clean:$(TARGET):unregserver : $(_linkTargets[1]) ;
	}

	Depends clean : clean:$(TARGET) ;
	NotFile clean:$(TARGET) ;
	Always clean:$(TARGET) ;
	Depends allclean : allclean:$(TARGET) ;
	NotFile allclean:$(TARGET) ;
	Always allclean:$(TARGET) ;
	Depends allclean:$(TARGET) : clean:$(TARGET) ;
	Clean clean:$(TARGET) : $(_linkTargets) ;

	local linkFlags =
		[ FLibraryPaths [ _retrieveVar LINKDIRECTORIES : $(TARGET) : $(CONFIG) : $(PLATFORM) ] ]
		[ FLibraryPaths [ _retrieveVar LINKDIRECTORIES : * : $(CONFIG) : $(PLATFORM) ] ]
		[ _retrieveVar LINKFLAGS : $(TARGET) : $(CONFIG) : $(PLATFORM) ]
		[ _retrieveVar LINKFLAGS : * : $(CONFIG) : $(PLATFORM) ] ;

	if $(COMPILER) in vc6 vs2003 vs2005 vs2008 {
		if ! ( nodefaults in $(OPTIONS) ) {
			if windows in $(OPTIONS) {
				linkFlags += /SUBSYSTEM:WINDOWS ;
			} else {
				linkFlags += /SUBSYSTEM:CONSOLE ;
			}
		}
		linkFlags += /DLL ;
	} else if $(COMPILER) = mingw {
		linkFlags += -shared ;
	} else if $(COMPILER) = gcc  &&  $(OS) = MACOSX {
		if module in $(OPTIONS) {
			linkFlags += -bundle -undefined dynamic_lookup ;
		} else {
			linkFlags += -dynamiclib -install_name $(_t:T) ;
		}
	}
#	else if $(UNIX)
#	{
#		Exit SharedLibraryFromObjects not implemented. ;
#	}

	local linkLibs =
		[ _retrieveVar LINKLIBS : $(TARGET) : $(CONFIG) : $(PLATFORM) ]
		[ _retrieveVar LINKLIBS : * : $(CONFIG) : $(PLATFORM) ] ;

	local needLibs =
		[ _retrieveVar NEEDLIBS : $(TARGET) : $(CONFIG) : $(PLATFORM) ]
		[ _retrieveVar NEEDLIBS : * : $(CONFIG) : $(PLATFORM) ] ;

	NEEDLIBS on $(_linkTargets) = $(needLibs:S=$(SUFLIB)) ;
	Depends $(_linkTargets) : $(needLibs) ;

	if $(MSVCNT) {
	    # Clean the .pdb (etc) files.
		local sufs = .pdb .map .exp .ilk ;
	    local zap = $(_t:S=$(sufs)) ;
	    MakeLocate $(zap) : $(outputPath) ;
	    Clean clean:$(TARGET) : $(zap) ;

	    Depends $(zap) : $(_linkTargets) ;

		if ( nomanifest in $(OPTIONS) ) {
			linkFlags -= /INCREMENTAL ;
		} else if $(COMPILER) in vs2005 vs2008  &&  ! ( nomanifest in $(OPTIONS) ) {
			_writeManifest $(TARGET) : $(_linkTargets) : 2 ;
			_linkManifest $(_linkTargets) ;
			linkFlags += /MANIFEST /MANIFESTFILE:$(LOCATE_TARGET)/$(_t:G=).intermediate.manifest ;
		}
	}

	LINKFLAGS on $(_linkTargets) = $(linkFlags) ;
	LINKLIBS on $(_linkTargets) = $(linkLibs) ;

	UseCommandLine $(_linkTargets) : $(linkFlags) $(linkLibs) $(needLibs) $(_s) ;

	local linkRule = Link ;

	if $(COMPILER) in vs2005 vs2008 {
		if nomanifest in $(OPTIONS) {
			linkRule = LinkNoManifest ;
		} else if $(CONFIG) = debug {
			linkRule = LinkDebug ;
		}
	}

	$(linkRule) $(_linkTargets) : $(_s) ;
	Includes $(_s) : $(_s) ;

	if $(regserver) {
		RegSvr32 $(_linkTargets[1]) ;
	}

	LINK_TARGET on $(TARGET) = $(_linkTargets) ;
}


########################################################################
########################################################################

rule CreatePrecompiledHeader TARGET : NAME : HEADER
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	HEADER ?= $(NAME[1]:S=.h) ;
	local SOURCE = $(NAME[1]) ;
	if ! $(SOURCE:S)
	{
		SOURCE = $(SOURCE:S=.cpp) ;
	}
	local cppPchFilename = $(SOURCE:G=$(grist)) ;
	PCH on $(cppPchFilename) = $(SOURCE) $(HEADER) 1 ;
}


rule UsePrecompiledHeader TARGET : NAME : HEADER : FILES
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	local SOURCE = $(NAME[1]) ;
	if ! $(SOURCE:S)
	{
		SOURCE = $(SOURCE:S=.cpp) ;
	}
	local cppPchFilename = $(SOURCE:G=$(grist)) ;
	local file ;
	for file in $(FILES:G=$(grist))
	{
		if $(file:S) in .cpp .c  &&  $(file) != $(cppPchFilename)
		{
			PCH on $(file) = $(SOURCE) $(HEADER) ;
		}
	}
}


rule PrecompiledHeader TARGET : NAME : FILES
{
	if ! $(NAME[1]:S)
	{
		NAME[1] = $(NAME[1]:S=.cpp) ;
	}
	local header = $(NAME[2]:E=$(NAME[1]:S=.h)) ;
	CreatePrecompiledHeader $(TARGET) : $(NAME[1]) $(NAME[1]:S) : $(header) ;
	UsePrecompiledHeader $(TARGET) : $(NAME[1]) $(NAME[1]:S) : $(header) : $(FILES) ;
}


########################################################################
########################################################################

# Originally from http://maillist.perforce.com/pipermail/jamming/2004-July.txt.gz
# windows resource compiler.
rule ResourceCompiler PARENT : SOURCES : OPTIONS
{
	PARENT = [ _retrieveActiveTargetName $(PARENT) ] ;
	local grist = $(PARENT) ;

	SOURCES = $(SOURCES:G=$(grist)) ;
	local TARGETS = $(SOURCES:S=.res) ;

	SearchSource $(SOURCES) ;
	MakeLocate $(TARGETS) : $(LOCATE_TARGET) ;

	Depends $(TARGETS) : $(SOURCES) ;
	Clean clean:$(PARENT) : $(TARGETS) ;

	RCDEFINES on $(TARGETS) +=
		[ on $(PARENT) Var RCDEFINES ]
		[ on * Var RCDEFINES ]
	;

	RCFLAGS on $(TARGETS) +=
		[ on $(PARENT) Var RCFLAGS ]
		[ on * Var RCFLAGS ]
	;

	RCHDRS on $(TARGETS) +=
		$(SEARCH_SOURCE)
		[ on $(PARENT) Var RCHDRS ]
		[ on * Var RCHDRS ]
		$(SUBDIRHDRS)
		$(STDHDRS)
	;

	UseCommandLine $(TARGETS) :
			[ on $(TARGETS) Var RCDEFINES ]
			[ on $(TARGETS) Var RCFLAGS ]
			[ on $(TARGETS) Var RCHDRS ]
	;

	if quiet in $(OPTIONS)
	{
		ResourceCompileQuiet $(TARGETS) : $(SOURCES) ;
	}
	else
	{
		ResourceCompile $(TARGETS) : $(SOURCES) ;
	}

	return $(TARGETS) ;
}

actions ResourceCompile
{
	SET INCLUDE=$(RCHDRS:\\J=;)
	"$(RC:\\)" /fo $(1) $(RCFLAGS) /d$(RCDEFINES) $(2)
}

actions quietly ResourceCompileQuiet
{
	SET INCLUDE=$(RCHDRS:\\J=;)
	"$(RC:\\)" /fo $(1) $(RCFLAGS) /d$(DEFINES) $(2)
}

# Set resource compiler options
rule _RcOptions TARGET : VARIABLE : RESOURCE_NAME : OPTIONS
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;

	local target ;
	if $(OPTIONS)
	{
		target = $(RESOURCE_NAME:S=.res:G=$(grist)) ;
	}
	else
	{
		OPTIONS = $(RESOURCE_NAME) ;
		target = $(TARGET) ;
	}

	$(VARIABLE) on $(target) += $(OPTIONS) ;
}


rule RcFlags TARGET : RESOURCE_NAME : FLAGS
{
	_RcOptions $(TARGET) : RCFLAGS : $(RESOURCE_NAME) : $(FLAGS) ;
}

rule RcDefines TARGET : RESOURCE_NAME : DEFINES
{
	_RcOptions $(TARGET) : RCDEFINES : $(RESOURCE_NAME) : $(DEFINES) ;
}

rule RcIncludeDirectories TARGET : RESOURCE_NAME : HDRS
{
	_RcOptions $(TARGET) : RCHDRS : $(RESOURCE_NAME) : $(HDRS) ;
}


########################################################################
########################################################################

ACTIVE_PROJECT = "" ;

rule ActiveProject PROJECT
{
	ACTIVE_PROJECT = $(PROJECT) ;
}


rule CFlags TARGET : FLAGS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	CCFLAGS.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(FLAGS) ;
}


rule C++Flags TARGET : FLAGS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	C++FLAGS.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(FLAGS) ;
}


rule CRuntimeType TARGET : TYPE : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_PLATFORM ?= $(PLATFORM) ;
	if $(COMPILER) in vs2003 vs2005 vs2008
	{
		if ! $(TYPE)  ||  $(TYPE) = dynamic
		{
			CCFLAGS.$(THE_PLATFORM).debug on $(TARGET) -= /MTd ;
			CCFLAGS.$(THE_PLATFORM).release on $(TARGET) -= /MT ;
			CCFLAGS.$(THE_PLATFORM).releaseltcg on $(TARGET) -= /MT ;
			CCFLAGS.$(THE_PLATFORM).debug on $(TARGET) += /MDd ;
			CCFLAGS.$(THE_PLATFORM).release on $(TARGET) += /MD ;
			CCFLAGS.$(THE_PLATFORM).releaseltcg on $(TARGET) += /MD ;

			C++FLAGS.$(THE_PLATFORM).debug on $(TARGET) -= /MTd ;
			C++FLAGS.$(THE_PLATFORM).release on $(TARGET) -= /MT ;
			C++FLAGS.$(THE_PLATFORM).releaseltcg on $(TARGET) -= /MT ;
			C++FLAGS.$(THE_PLATFORM).debug on $(TARGET) += /MDd ;
			C++FLAGS.$(THE_PLATFORM).release on $(TARGET) += /MD ;
			C++FLAGS.$(THE_PLATFORM).releaseltcg on $(TARGET) += /MD ;
		}
		else if $(TYPE) = static
		{
			CCFLAGS.$(THE_PLATFORM).debug on $(TARGET) -= /MDd ;
			CCFLAGS.$(THE_PLATFORM).release on $(TARGET) -= /MD ;
			CCFLAGS.$(THE_PLATFORM).releaseltcg on $(TARGET) -= /MD ;
			CCFLAGS.$(THE_PLATFORM).debug on $(TARGET) += /MTd ;
			CCFLAGS.$(THE_PLATFORM).release on $(TARGET) += /MT ;
			CCFLAGS.$(THE_PLATFORM).releaseltcg on $(TARGET) += /MT ;

			C++FLAGS.$(THE_PLATFORM).debug on $(TARGET) -= /MDd ;
			C++FLAGS.$(THE_PLATFORM).release on $(TARGET) -= /MD ;
			C++FLAGS.$(THE_PLATFORM).releaseltcg on $(TARGET) -= /MD ;
			C++FLAGS.$(THE_PLATFORM).debug on $(TARGET) += /MTd ;
			C++FLAGS.$(THE_PLATFORM).release on $(TARGET) += /MT ;
			C++FLAGS.$(THE_PLATFORM).releaseltcg on $(TARGET) += /MT ;
		}
	}
}


rule Defines TARGET : DEFINES : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	DEFINES.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(DEFINES) ;
}


rule DefFile TARGET : SOURCES
{
	if $(COMPILER) in vc6 vs2002 vs2003 vs2005 vs2008
	{
		TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
		local grist = $(TARGET) ;
		SOURCES = $(SOURCES:G=$(grist)) ;
		SEARCH on $(SOURCES) = $(SEARCH_SOURCE) ;
		Depends $(TARGET) : $(SOURCES) ;
		LinkFlags $(TARGET) : /DEF:"$(SOURCES:T)" ;
	}
}


rule ExcludeFromBuild TARGET : SOURCES
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	EXCLUDED_FROM_BUILD on $(SOURCES:G=$(grist)) = true ;
}


rule IncludeDirectories TARGET : INCLUDEPATHS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	HDRS.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(INCLUDEPATHS:R=$(SUBDIR)) ;
}


rule LinkDirectories TARGET : DIRECTORIES : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	LINKDIRECTORIES.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(DIRECTORIES:R=$(SUBDIR)) ;
}


rule LinkFlags TARGET : FLAGS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	LINKFLAGS.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(FLAGS) ;
}


rule LinkLibraries TARGET : LIBRARIES : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	Depends $(TARGET) : $(LIBRARIES) ;
	Depends allclean:$(TARGET) : allclean:$(LIBRARIES) ;
	NotFile allclean:$(TARGET) ;
	Always allclean:$(TARGET) ;

	local gristLibraries ;
	local lib ;
	for lib in $(LIBRARIES)
	{
		gristLibraries += $(lib:G=$(lib))$(SUFLIB) ;
	}
	NEEDLIBS.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(gristLibraries) ;
}


rule LinkPrebuiltLibraries TARGET : LIBRARIES : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	LINKLIBS.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(LIBRARIES:S=$(SUFLIB)) ;
}


rule NoWorkspace WORKSPACE_NAME
{
}


rule ObjectCFlags TARGET : SOURCES : FLAGS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	local sources = $(SOURCES:I=\\.c$) ;
	local objTargets = $(sources:S=$(SUFOBJ):G=$(grist)) ;
	CCFLAGS.$(THE_PLATFORM).$(THE_CONFIG) on $(objTargets) += $(FLAGS) ;
}


rule ObjectC++Flags TARGET : SOURCES : FLAGS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	local sources = $(SOURCES:I=\\.cpp$) ;
	local objTargets = $(sources:S=$(SUFOBJ):G=$(grist)) ;
	C++FLAGS.$(THE_PLATFORM).$(THE_CONFIG) on $(objTargets) += $(FLAGS) ;
}


rule ObjectDefines TARGET : SOURCES : DEFINES : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	local objTargets = $(SOURCES:S=$(SUFOBJ):G=$(grist)) ;
	DEFINES.$(THE_PLATFORM).$(THE_CONFIG) on $(objTargets) += $(DEFINES) ;
}


rule ObjectIncludeDirectories TARGET : SOURCES : INCLUDEPATHS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	local objTargets = $(SOURCES:S=$(SUFOBJ):G=$(grist)) ;
	HDRS.$(THE_PLATFORM).$(THE_CONFIG) on $(objTargets) += $(INCLUDEPATHS) ;
}


rule OutputName TARGET : NAME : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	OUTPUTNAME.$(THE_PLATFORM:E=*).$(THE_CONFIG:E=*) on $(TARGET) = $(NAME) ;
}


rule OutputPath TARGET : OUTPUTPATH : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	LOCATE.$(THE_PLATFORM:E=*).$(THE_CONFIG:E=*) on $(TARGET) = $(OUTPUTPATH:R=$(SUBDIR:E="")) ;
}


rule OutputPostfix TARGET : POSTFIX : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	OUTPUTPOSTFIX.$(THE_PLATFORM:E=*).$(THE_CONFIG:E=*) on $(TARGET) = $(POSTFIX:E=*off*) ;
}


rule OutputPostfixClear TARGET : POSTFIX : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	OUTPUTPOSTFIX.$(THE_PLATFORM:E=*).$(THE_CONFIG:E=*) on $(TARGET) = ;
}


rule OutputSuffix TARGET : SUFFIX : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local NO_DOT_SUFFIX = [ Match \\.?(.+) : $(SUFFIX) ] ;
	SUFFIX = .$(NO_DOT_SUFFIX) ;
	OUTPUTSUFFIX.$(THE_PLATFORM:E=*).$(THE_CONFIG:E=*) on $(TARGET) = $(SUFFIX) ;
}


rule Project PROJECT_NAME : SOURCES
{
}


rule ProjectGroup TARGET : FOLDERNAME : PROJECTS
{
}


rule SearchSource SOURCES
{
	on $(SOURCES) if ! $(SEARCH)
	{
		SEARCH on $(SOURCES) = $(SEARCH_SOURCE) ;
	}
}


rule SourceGroup TARGET : FOLDERNAME : SOURCES
{
}


rule Workspace WORKSPACE_NAME : TARGETS
{
}


#
# Now include the user's Jamfile.
#

include $(JAMFILE) ;
