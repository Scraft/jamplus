#
# /+\
# +\	Portions copyright 1993-2002 Christopher Seiwald and Perforce Software, Inc.
# \+/
#
# This file is part of Jam - see jam.c for Copyright information.
#

# Helper rule used to get value of a variable bound to specific target.
# [ on <target> Var <var> ]
rule Var {
  return $($(1)) ;
}


# Helper rule used to get value of a variable bound to specific target.
rule SearchVar {
	local key ;
	for key in $(1)
	{
		local value = $($(key)) ;
		if $(value) { return $(value) ; }
	}
	return $(2) ;
}


SPACE = " " ;
TAB = "	" ;
NEWLINE = "
" ;

JAMBASE_VERSION = "JamPlus 0.3 (2009.03.20)" ;

# Initialize variables
#

CONFIG ?= release ;

VALID_CONFIGS ?= debug release releaseltcg ;

switch $(OS)
{
	case NT :
		VALID_PLATFORMS ?= win32 ;

		PLATFORM ?= win32 ;

	case MACOSX :
		VALID_PLATFORMS ?= macosx iphone iphonesimulator ;

		PLATFORM ?= macosx ;
}

if ! $(CONFIG) in * $(VALID_CONFIGS)
{
	Exit "* jam: CONFIG must be one of the following:" $(VALID_CONFIGS:J=$(SPACE)) ;
}

if ! $(PLATFORM) in * $(VALID_PLATFORMS)
{
	Exit "* jam: PLATFORM must be one of the following:" $(VALID_PLATFORMS:J=$(SPACE)) ;
}

#
# OS specific variable settings
#

VISUAL_STUDIO_FORCE_VERSION = 9.0 ;

rule FindVisualStudio VERSION
{
	if $(MSVCNT)
	{
		return ;
	}

	switch $(VERSION)
	{
		case 10.0 :
			local key = HKEY_CURRENT_USER SOFTWARE Microsoft VisualStudio $(VERSION)_Config InstallDir ;
			MSVCNT = [ W32_GETREG $(key) ] ;

			VS100COMNTOOLS = $(VS100COMNTOOLS:J=" ") ;
			if ! $(MSVCNT) && $(VS100COMNTOOLS) {
				MSVCNT = $(VS100COMNTOOLS) ;
			}
			if $(MSVCNT)
			{
				MSVCNT = $(MSVCNT)..\\..\\vc ;
				MSVCNT = $(MSVCNT:R=$(MSVCNT)) ;
				MSVCNT_PATH = $(MSVCNT)/../Common7/IDE ;
				VS2010 = 1 ;

				local key = HKEY_LOCAL_MACHINE SOFTWARE Microsoft "Microsoft SDKs" Windows CurrentInstallFolder ;
				MSSDK = [ W32_GETREG $(key) ] ;
				MSSDK ?= $(MSVCNT) ;
				MSSDK_STDHDRS = "$(MSVCNT)/include" "$(MSSDK)/Include" ;
				MSSDK_LINKDIRECTORIES = "$(MSVCNT)/lib" "$(MSSDK)/Lib" ;
				return vs2010 ;
			}

		case 9.0 :
			local key = HKEY_LOCAL_MACHINE SOFTWARE Microsoft VisualStudio $(VERSION) InstallDir ;
			MSVCNT = [ W32_GETREG $(key) ] ;
			VS90COMNTOOLS = $(VS90COMNTOOLS:J=" ") ;
			if ! $(MSVCNT) && $(VS90COMNTOOLS) {
				MSVCNT = $(VS90COMNTOOLS) ;
			}
			if $(MSVCNT)
			{
				MSVCNT = $(MSVCNT)..\\..\\vc ;
				MSVCNT = $(MSVCNT:R=$(MSVCNT)) ;
				MSVCNT_PATH = $(MSVCNT)/../Common7/IDE ;
				VS2008 = 1 ;

				local key = HKEY_LOCAL_MACHINE SOFTWARE Microsoft "Microsoft SDKs" Windows CurrentInstallFolder ;
				MSSDK = [ W32_GETREG $(key) ] ;
				MSSDK ?= $(MSVCNT) ;
				MSSDK_STDHDRS = "$(MSVCNT)/include" "$(MSSDK)/Include" ;
				MSSDK_LINKDIRECTORIES = "$(MSVCNT)/lib" "$(MSSDK)/Lib" ;
				return vs2008 ;
			}

		case 8.0 :
			local key = HKEY_LOCAL_MACHINE SOFTWARE Microsoft VisualStudio $(VERSION) InstallDir ;
			MSVCNT = [ W32_GETREG $(key) ] ;
			if ! $(MSVCNT) && $(VS80COMNTOOLS) {
				MSVCNT = $(VS80COMNTOOLS) ;
			}
			if $(MSVCNT)
			{
				MSVCNT = @($(MSVCNT)..\\..\\VC:R=$(MSVCNT)) ;
				MSVCNT_PATH = @($(MSVCNT)/../Common7/IDE:R=) ;
				VS2005 = 1 ;
				MSSDK = $(MSVCNT) ;
				MSSDK_STDHDRS = "$(MSSDK)/include" "$(MSSDK)/PlatformSDK/Include" ;
				MSSDK_LINKDIRECTORIES = "$(MSVCNT)/lib" "$(MSVCNT)/PlatformSDK/lib" ;
				return vs2005 ;
			}

		case 7.1 :
			local key = HKEY_LOCAL_MACHINE SOFTWARE Microsoft VisualStudio $(VERSION) InstallDir ;
			MSVCNT = [ W32_GETREG $(key) ] ;
			if ! $(MSVCNT) && $(VS71COMNTOOLS) {
				MSVCNT = $(VS71COMNTOOLS) ;
			}
			if $(MSVCNT)
			{
				MSVCNT = $(MSVCNT)\\..\\..\\vc7 ;
				MSVCNT = $(MSVCNT:R=$(MSVCNT)) ;
				MSVCNT_PATH = $(MSVCNT)/../Common7/IDE ;
				MSSDK = $(MSVCNT) ;
				MSSDK_STDHDRS = "$(MSSDK)/include" "$(MSSDK)/PlatformSDK/Include" ;
				MSSDK_LINKDIRECTORIES = "$(MSVCNT)/lib" "$(MSVCNT)/PlatformSDK/lib" ;
				return vs2003 ;
			}

		case 7.0 :
			local key = HKEY_LOCAL_MACHINE SOFTWARE Microsoft
				VisualStudio $(VERSION) InstallDir ;
			MSVCNT = [ W32_GETREG $(key) ] ;
			if ! $(MSVCNT) && $(VS70COMNTOOLS) {
				MSVCNT = $(VS70COMNTOOLS) ;
			}
			if $(MSVCNT)
			{
				MSVCNT = $(MSVCNT)\\..\\..\\vc7 ;
				return vs2002 ;
			}

		case 6.0 :
		    local key = HKEY_LOCAL_MACHINE SOFTWARE Microsoft DevStudio $(VERSION) Products "Microsoft Visual C++" ProductDir ;
		    MSVCNT = [ W32_GETREG $(key) ] ;
			MSVCNT_PATH = "$(MSVCNT)/../Common/MSDev98/Bin" ;
			MSSDK = $(MSVCNT) ;
			MSSDK_STDHDRS = "$(MSSDK)/Include" ; # "$(MSSDK)/PlatformSDK/Include" ;
			MSSDK_LINKDIRECTORIES = "$(MSVCNT)/Lib" ; # "$(MSVCNT)/PlatformSDK/lib" ;
			return vc6 ;
	}
}


rule FindMinGW
{
	local PATHS =
		c:/mingw
		d:/mingw
	;

	local gcc = [ Glob $(PATHS)/bin : gcc.exe ] ;
	if ! $(gcc)
	{
		return ;
	}

	MINGW_ROOT = [ Match (.+)/bin : $(gcc[1]) ] ;
}


rule ToolChain THE_COMPILER : THE_PLATFORM : THE_CONFIG
{
	THE_COMPILER ?= $(COMPILER) ;
	THE_PLATFORM ?= $(PLATFORM) ;
	THE_CONFIG ?= $(CONFIG) ;

	if $(NT)
	{
		MSVCNT ?= $(MSVCDIR) ;
		MSVCNT ?= $(MSVCDir) ;

		MV		?= move /y ;
		CP		?= copy ;
		RM		?= del /f/q ;
		RMDIR	?= rmdir /s/q ;
		SLASH	?= / ;
		SUFEXE	?= .exe ;
		SUFMODULE ?= .dll ;
		SUFSHAREDLIB ?= .dll ;
		SUFRES	?= .res ;

		# Do we need to attempt to detect the compiler?
		if ! $(THE_COMPILER)
		{
			if ! $(MSVCNT)
			{
				MSVCNT_PATH = ;
				for ver in $(VISUAL_STUDIO_FORCE_VERSION) 10.0 9.0 8.0 7.1 7.0 6.0
				{
					COMPILER = [ FindVisualStudio $(ver) ] ;
					if $(COMPILER)
					{
						break ;
					}
				}
				if ! $(COMPILER)
				{
					Exit ** Unable to find the specified compiler. ;
				}
			}
		}
		else
		{
			COMPILER = $(THE_COMPILER) ;
		}

		if $(COMPILER) in vc6 vs2003 vs2005 vs2008 vs2010
		{
			SUFLIB	?= .lib ;
			SUFOBJ	?= .obj ;

			MSVCNT = ;
			switch $(COMPILER)
			{
				case vc6 :
					COMPILER = [ FindVisualStudio 6.0 ] ;
				case vs2003 :
					COMPILER = [ FindVisualStudio 7.1 ] ;
					COMPILER ?= [ FindVisualStudio 7.0 ] ;
				case vs2005 :
					COMPILER = [ FindVisualStudio 8.0 ] ;
				case vs2008 :
					COMPILER = [ FindVisualStudio 9.0 ] ;
				case vs2010 :
					COMPILER = [ FindVisualStudio 10.0 ] ;
			}

			local debugRtcFlags ;
			if $(COMPILER) != vc6 {
				DEFINES.win32.* on * += WIN32 WINDOWS _CRT_SECURE_NO_DEPRECATE _CRT_SECURE_NO_WARNINGS _CRT_NONSTDC_NO_DEPRECATE ;
				debugRtcFlags += /RTC1 ;
			}

			MSVCNT		?= $(MSVCDIR) ;

			MSVCBIN ?= $(MSVCNT)/bin/ ;

			CCFLAGS.win32.debug on * 		?= /Od /Gm /EHsc $(debugRtcFlags) /MDd /W3 /Zi ;
			CCFLAGS.win32.release on * 		?= /O2 /Oi /EHsc /Gy /MD /W3 /Zi ;
			CCFLAGS.win32.releaseltcg on * 	?= [ on * Var CCFLAGS.win32.release ] /GL ;
			C++FLAGS.win32.* on *			?= [ on * Var CCFLAGS.win32.* ] ;
			C++FLAGS.win32.debug on *		?= [ on * Var CCFLAGS.win32.debug ] ;
			C++FLAGS.win32.release on *		?= [ on * Var CCFLAGS.win32.release ] ;
			C++FLAGS.win32.releaseltcg on *	?= [ on * Var CCFLAGS.win32.releaseltcg ] ;

			DEFINES.*.debug on * += _DEBUG DEBUG ;
			DEFINES.*.release on * += NDEBUG ;
			DEFINES.*.releaseltcg on * += NDEBUG ;

			LIBFLAGS.win32.debug on * = ;
			LIBFLAGS.win32.release on * = ;
			LIBFLAGS.win32.releaseltcg on * = /LTCG ;

			LINKDIRECTORIES.*.*	on * += $(MSSDK_LINKDIRECTORIES) ;
			LINKFLAGS.win32.debug on * = /INCREMENTAL:YES /DEBUG /MACHINE:X86 ;
			LINKFLAGS.win32.release on * = /INCREMENTAL:NO /DEBUG /MACHINE:X86 /OPT:REF /OPT:ICF ;
			LINKFLAGS.win32.releaseltcg on * = [ on * Var LINKFLAGS.win32.release ] /LTCG ;

			AR			= "$(MSVCBIN)lib" ;
			AS			= "$(MSVCBIN)masm386" ;
			CC			= "$(MSVCBIN)cl" ;
			C++			= "$(CC)" ;
			LINK		= "$(MSVCBIN)link" ;
			MKDIR		= mkdir ;
			MKDIR_RECURSIVE = ;
			MT			= "$(MSSDK)/bin/mt" ;
			if $(COMPILER) = vc6 {
				RC			= "$(MSVCNT)/../Common/MSDev98/Bin/rc" ;
			} else {
				RC			= "$(MSSDK)/bin/RC" ;
			}
			STDHDRS		?= "$(MSSDK_STDHDRS)" ;
			UNDEFFLAG	?= "/u _" ;

			NOARSCAN = true ;
			NOARUPDATE = true ;
		}
		else if $(COMPILER) = mingw
		{
			FindMinGW ;

			SUFLIB	?= .a ;
			SUFOBJ	?= .o ;

			DEFINES.*.* on * += MINGW ;
			DEFINES.*.debug on * += _DEBUG DEBUG ;
			DEFINES.*.release on * += NDEBUG ;

			CCFLAGS.win32.debug on * 	= -g -O0 ;
			CCFLAGS.win32.release on * 	= -g -O2 ;
			C++FLAGS.win32.* on *		?= [ on * Var CCFLAGS.win32.* ] ;
			C++FLAGS.win32.debug on *	?= [ on * Var CCFLAGS.win32.debug ] ;
			C++FLAGS.win32.release on *	?= [ on * Var CCFLAGS.win32.release ] ;

			AR			?= "$(MINGW_ROOT)/bin/ar" ru ;
			CC			?= "$(MINGW_ROOT)/bin/gcc" ;
			C++			?= "$(MINGW_ROOT)/bin/g++" ;
			MKDIR		?= mkdir ;
			MKDIR_RECURSIVE = ;
			RANLIB		?= "$(MINGW_ROOT)/bin/ranlib" ;
			SUFEXE		?= .exe ;

			PCHCCFLAGS = -x c-header ;
			PCHC++FLAGS = -x c++-header ;
			PCHMFLAGS = -x objective-c-header ;
			PCHMMFLAGS = -x objective-c++-header ;

			NOARSCAN = true ;
			NOARUPDATE = true ;
		}
		else
		{
			EXIT On NT, set BCCROOT, MSVCDIR, MSVCNT, or MSVC to the root
				of the Borland or Microsoft directories. ;
		}
	}
	else if $(UNIX)
	{
		COMPILER = gcc ;

		SUFLIB	?= .a ;
		SUFOBJ	?= .o ;

		SUFSHAREDLIB ?= .so ;
		SUFMODULE ?= .so ;

		NOARSCAN = true ;
		NOARUPDATE = true ;

		DEFINES.*.debug on * += _DEBUG DEBUG ;
		DEFINES.*.release on * += NDEBUG ;

		CCFLAGS.*.debug on * 		= -g -O0 ;
		CCFLAGS.*.release on * 		= -g -O2 ;
		CCFLAGS.*.releaseltcg on * 	= -g -O3 ;
		C++FLAGS.*.* on *			?= [ on * Var CCFLAGS.*.* ] ;
		C++FLAGS.*.debug on *		?= [ on * Var CCFLAGS.*.debug ] ;
		C++FLAGS.*.release on *		?= [ on * Var CCFLAGS.*.release ] ;
		C++FLAGS.*.releaseltcg on *	?= [ on * Var CCFLAGS.*.releaseltcg ] ;

		MFLAGS.*.debug on * 		= -g -O0 ;
		MFLAGS.*.release on * 		= -g -O2 ;
		MFLAGS.*.releaseltcg on * 	= -g -O2 ;
		MMFLAGS.*.* on *			?= [ on * Var MFLAGS.*.* ] ;
		MMFLAGS.*.debug on *		?= [ on * Var MFLAGS.*.debug ] ;
		MMFLAGS.*.release on *		?= [ on * Var MFLAGS.*.release ] ;
		MMFLAGS.*.releaseltcg on *	?= [ on * Var MFLAGS.*.releaseltcg ] ;

		switch $(OS)
		{
			case CYGWIN :
				DEFINES.*.* on * += __cygwin__ ;
				CC			?= gcc ;
				C++			?= g++ ;
				JAMSHELL	?= sh -c ;
				RANLIB		?= "" ;
				SUFEXE		?= .exe ;

			case MACOSX :
				DEFINES.*.* on * += ;
				CC			?= gcc ;
				C++			?= g++ ;
				LINK		?= $(C++) ;
				SUFMODULE	= .dylib ;
				
				local developerRoot ;
				local isysroot ;

				switch $(PLATFORM) {
					case macosx :
						developerRoot = /Developer/SDKs ;
						SUBPLATFORM ?= 10.5 ;
						switch $(SUBPLATFORM) {
							case 10.4u :	isysroot = $(developerRoot)/MacOSX10.4u.sdk ;
							case 10.5 :		isysroot = $(developerRoot)/MacOSX10.5.sdk ;
							case * :		Exit "* MacOSX_SDK: Unsupported subplatform $(SUBPLATFORM) for SDK platform $(PLATFORM)." ;
						}
						developerRoot = $(isysroot) ;

					case iphone :
						developerRoot = /Developer/Platforms/iPhoneOS.platform/Developer ;
						SUBPLATFORM ?= 2.2 ;
						switch $(SUBPLATFORM) {
							case 2.0 :	isysroot = $(developerRoot)/SDKs/iPhoneOS2.0.sdk ;
							case 2.1 :	isysroot = $(developerRoot)/SDKs/iPhoneOS2.1.sdk ;
							case 2.2 :	isysroot = $(developerRoot)/SDKs/iPhoneOS2.2.sdk ;
							case 3.0 :	isysroot = $(developerRoot)/SDKs/iPhoneOS3.0.sdk ;
							case * :	Exit "* MacOSX_SDK: Unsupported subplatform $(SUBPLATFORM) for SDK platform $(PLATFORM)." ;
						}

					case iphonesimulator :
						developerRoot = /Developer/Platforms/iPhoneSimulator.platform/Developer ;
						SUBPLATFORM ?= 2.2 ;
						switch $(SUBPLATFORM) {
							case 2.0 :	isysroot = $(developerRoot)/SDKs/iPhoneSimulator2.0.sdk ;
							case 2.1 :	isysroot = $(developerRoot)/SDKs/iPhoneSimulator2.1.sdk ;
							case 2.2 :	isysroot = $(developerRoot)/SDKs/iPhoneSimulator2.2.sdk ;
							case 3.0 :	isysroot = $(developerRoot)/SDKs/iPhoneSimulator3.0.sdk ;
							case * :	Exit "* MacOSX_SDK: Unsupported subplatform $(SUBPLATFORM) for SDK platform $(PLATFORM)." ;
						}
				}

				CCFLAGS.$(PLATFORM).* on * = -isysroot $(isysroot) ;
				C++FLAGS.$(PLATFORM).* on * = -isysroot $(isysroot) ;
				MFLAGS.$(PLATFORM).* on * = -isysroot $(isysroot) ;
				MMFLAGS.$(PLATFORM).* on * = -isysroot $(isysroot) ;
				LINKFLAGS.$(PLATFORM).* on * = -isysroot $(isysroot) ;
				MACOSX_SDK_DEVELOPER_ROOT on * = $(developerRoot) ;
		}

		# UNIX defaults

		CCFLAGS		?= ;
		C++FLAGS	?= $(CCFLAGS) ;
		CHMOD		?= chmod ;
		CHGRP		?= chgrp ;
		CHOWN		?= chown ;
		LINKFLAGS	?= $(CCFLAGS) ;
		LINKLIBS	?= ;
		MKDIR_RECURSIVE = 1 ;
		OPTIM		?= -O ;
		RANLIB		?= ranlib ;

		PCHCCFLAGS = -x c-header ;
		PCHC++FLAGS = -x c++-header ;
		PCHMFLAGS = -x objective-c-header ;
		PCHMMFLAGS = -x objective-c++-header ;
	}


	#
	# General defaults; a lot like UNIX
	#

	AR			?= ar ru ;
	AS			?= as ;
	ASFLAGS		?= ;
	AWK			?= awk ;
	BINDIR		?= /usr/local/bin ;
	C++			?= cc ;
#	C++FLAGS	?= ;
	CC			?= cc ;
#	CCFLAGS		?= ;
	CP			?= cp -f ;
	CRELIB		?= ;
	DOT			?= . ;
	DOTDOT		?= .. ;
	HDRS		?= ;
	JAMFILE		?= Jamfile.jam ;
	JAMRULES	?= Jamrules.jam ;
	LIBDIR		?= /usr/local/lib ;
	LINK		?= $(CC) ;
	LINKFLAGS	?= ;
	LINKLIBS	?= ;
	LN			?= ln ;
	MKDIR		?= mkdir -p ;
	MV			?= mv -f ;
	RM			?= rm -f ;
	RMDIR		?= $(RM) ;
	SLASH		?= / ;
	STDHDRS		?= /usr/include ;
	SUBDIRRULES ?= ;
	SUBDIRRESET ?= ASFLAGS HDRS C++FLAGS CCFLAGS ;
	SUFEXE		?= "" ;
	SUFLIB		?= .a ;
	SUFOBJ		?= .o ;
	UNDEFFLAG	?= "-u _" ;
}


HDRPATTERN =
		"^[ 	]*#[ 	]*include[ 	]*[<\"]([^\">]*)[\">].*$" ;

OSFULL = $(OS)$(OSVER)$(OSPLAT) $(OS)$(OSPLAT) $(OS)$(OSVER) $(OS) ;

ToolChain $(COMPILER) : $(PLATFORM) : $(CONFIG) ;


#
# Base dependencies - first for "bootstrap" kinds of rules
#

NotFile all allclean clean ;
Always allclean clean ;

#
# Rules
#

GENERATED_HEADERS = ;

rule HdrRule SOURCE : HEADERS
{
	# HdrRule source : headers ;

	# N.B.	This rule is called during binding, potentially after
	# the fate of many targets has been determined, and must be
	# used with caution: don't add dependencies to unrelated
	# targets, and don't set variables on $(SOURCE).

	# Tell Jam that anything depending on $(SOURCE) also depends on $(HEADERS),
	# set SEARCH so Jam can find the headers, but then say we don't
	# care if we can't actually find the headers (they may have been
	# within ifdefs),

	local s = $(HEADERS:G=$(HDRGRIST:E)) ;

	Includes $(SOURCE) : $(s) ;
## LOCAL CHANGE

	# If the directory holding this header isn't in HDRSEARCH,
	# add it, or Jam won't be able to find it internally and will
	# think it is stable in other projects.
	#
	# See http://maillist.perforce.com/pipermail/jamming/2001-December/001482.html
	if ! $(3:D) in $(HDRSEARCH)
	{
	    HDRSEARCH += $(3:D) ;
	}

## LOCAL CHANGE
	SEARCH on $(s) = $(HDRSEARCH) ;

	if $(GENERATED_HEADERS) {
		local header ;
		for header in $(s) {
			if ! $(header) in $(GENERATED_HEADERS) {
				NoCare $(header) ;
			}
		}
	} else {
		NoCare $(s) ;
	}

	# Propagate on $(SOURCE) to $(HEADERS)

	HDRSEARCH on $(s) = $(HDRSEARCH) ;
	HDRSCAN on $(s) = $(HDRSCAN) ;
	HDRRULE on $(s) = $(HDRRULE) ;
	HDRGRIST on $(s) = $(HDRGRIST) ;
}


rule IncludeModule MODULE_NAME
{
	local include_marker = included_module_$(MODULE_NAME:J=_) ;
	if $($(include_marker))
	{
		return ;
	}
	$(include_marker) = true ;

	include $(JAM_PROCESS_PATH)/../jammodules/$(MODULE_NAME).jam ;
}


rule FGristDirectories DIRECTORIES
{
	return $(DIRECTORIES:G=!dir!) ;
}


rule MakeLocate TARGETS : DIRECTORY
{
	# MakeLocate targets : directory ;

	# Sets special variable LOCATE on targets, and arranges
	# with MkDir to create target directory.

	# Note we grist the directory name with 'dir',
	# so that directory path components and other
	# targets don't conflict.

	if $(DIRECTORY)
	{
		DIRECTORY = $(DIRECTORY:R=$(SUBDIR:E="")) ;
	    LOCATE on $(TARGETS) = $(DIRECTORY) ;
	    Depends $(TARGETS) : $(DIRECTORY[1]:G=!dir!) ;
	    MkDir $(DIRECTORY[1]:G=!dir!) ;
	}
}

rule MkDir
{
	# MkDir directory ;

	# Make a directory and all its parent directories.

	# Ignore timestamps on directories: we only care if they
	# exist.

	NoUpdate $(<) ;

	# Don't create . or any directory already created.

	if $(<:G=) = $(DOT)
	{
		NotFile $(<) ;
	}
	else if ! $($(<)-mkdir)
	{
	    # Cheesy gate to prevent multiple invocations on same dir
	    # Arrange for jam dirs
	    # MkDir1 has the actions

	    $(<)-mkdir = true ;
	    MkDir1 $(<) ;

	    # Recursively make parent directories.
	    # $(<:P) = $(<)'s parent, & we recurse until root

	    local s = $(<:P) ;

	    # Don't try to create A: or A:\ on windows

	    if $(NT)
	    {
	        switch $(s)
			{
				case "*:"   : s = ;
				case "*:\\" : s = ;
				case "*:/" : s = ;
			}
	    }

	    if $(s) = $(<)
	    {
			# The parent is the same as the dir.
			# We're at the root, which some OS's can't stat, so we mark
			# it as NotFile.

	        NotFile $(s) ;
	    }
	    else if $(s:G=)
	    {
			if ! $(MKDIR_RECURSIVE)
			{
				# There's a parent; recurse.

				Depends $(<) : $(s) ;
				MkDir $(s) ;
			}
	    }
	}
}

rule RmTemps
{
	Temporary $(>) ;
}

rule SubDir
{
	#
	# SubDir TOP d1 d2 ... ;
	#
	# Support for a project tree spanning multiple directories.
	#
	# SubDir declares a Jamfile's location in a project tree, setting
	# Jambase variables (SEARCH_SOURCE, LOCATE_TARGET) so that source
	# files can be found.
	#
	# TOP is a user-select variable name for root of the tree, and
	# d1 d2 ...  are the directory elements that lead from the root
	# of the tree to the directory of the Jamfile.
	#
	# TOP can be set externally, but normally the first SubDir call
	# computes TOP as the path up from the current directory; the
	# path contains one ../ for each of d1 d2 ...
	#
	# SubDir reads once the project-specific rules file Jamrules
	# in the TOP directory, if present.  This can be overridden
	# with the variable TOPRULES.
	#
	# SubDir supports multiple, overlaid project trees:  SubDir
	# invocations with different TOPs can appear in the same Jamfile.
	# The location established by the first SubDir call is used set
	# the TOPs for the subsequent SubDir calls.
	#
	# SubDir's public variables:
	#
	#	$(TOP) = path from CWD to root.
	#	$(SUBDIR) = path from CWD to the directory SubDir names.
	#	$(SUBDIR_TOKENS) = path from $(TOP) to $(SUBDIR) as dir names
	#	$(SEARCH_SOURCE) = $(SUBDIR)
	#	$(LOCATE_SOURCE) = $(ALL_LOCATE_TARGET) $(SUBDIR)
	#	$(LOCATE_TARGET) = $(ALL_LOCATE_TARGET) $(SUBDIR)
	#	$(SOURCE_GRIST) = $(SUBDIR_TOKENS) with !'s
	#

	local _top = $(<[1]) ;
	local _tokens = $(<[2-]) ;

	ALL_SUBDIR_TOKENS = $(<) ;

	#
	# First time through sets up relative root and includes Jamrules.
	#

	if ! $(_top)
	{
	    Exit SubDir syntax error ;
	}

	if ! $($(_top)-SET)
	{
	    $(_top)-SET = true ;

	    # First time we've seen this TOP.
	    # We'll initialize a number of internal variables:
	    #
	    #	$(TOP-UP) = directories from ROOT to a common point
	    #	$(TOP-DOWN) = directories from common point to TOP
	    #	$(TOP-ROOT) = root directory for UP/DOWN -- normally CWD
	    #	$(SUBDIR_UP) = current value of $(TOP-UP)
	    #	$(SUBDIR_DOWN) = current value of $(TOP-DOWN)
	    #	$(SUBDIR_ROOT) = current value of $(TOP-ROOT)
	    #

	    if $($(_top))
	    {
			# TOP externally set.
			# We'll ignore the relative (UP/DOWN) path that
			# got us here, and instead remember the hard ROOT.

			$(_top)-UP = ;
			$(_top)-DOWN = ;
			$(_top)-ROOT = $($(_top)) ;
	    }
	    else
	    {
			# TOP not preset.

			# Establishing a new TOP.  In the simplest case,
			# (SUBDIR_UP/SUBDIR_DOWN/SUBDIR_ROOT unset), it's
			# merely a certain number of directories down from
			# the current directory, and FSubDirPath will set
			# TOP to a path consisting of ../ for each of the
			# elements of _tokens, because that represents how
			# far below TOP the current directory sits.
			#
			# In the more complicated case, the starting directory
			# isn't the directory of jam's invocation but an
			# location established by previous SubDir call.  The
			# starting directory is SUBDIR_UP directories up from
			# SUBDIR_ROOT, and then SUBDIR_DOWN directories down
			# from that.   If SUBDIR_ROOT is not set, that means
			# SUBDIR_DOWN and SUBDIR_UP represent the path from
			# the directory of jam's invocation.
			#
			# In the most complicated case, the _tokens also
			# represents directories down, because TOP is being
			# estalished in a directory other than TOP's root.
			# Hopefully, _tokens and SUBDIR_DOWN represent the
			# same final directory, relative to the new TOP and
			# the previous SubDIr's TOP.  To find the new TOP,
			# we have to chop off any common directories from
			# then ends of _tokens and SUBDIR_DOWN.  To do so,
			# we reverse each of them, call FStripCommon to
			# remove the initial common elements, and then
			# reverse them again.  After this process, if
			# both _tokens and SUBDIR_DOWN have elements, it
			# means the directory names estalished by the two
			# SubDir calls don't match, and a warning is issued.
			# All hell will likely break loose at this point,
			# since the whole SubDir scheme relies on the SubDir
			# calls accurately naming the current directory.

			# Strip common trailing elements of _tokens and SUBDIR_DOWN.

			_tokens = [ FReverse $(_tokens) ] ;
			SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;
			FStripCommon _tokens : SUBDIR_DOWN ;
			SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;
			_tokens = [ FReverse $(_tokens) ] ;

			if $(SUBDIR_DOWN) && $(_tokens)
			{
				Echo "Warning: SubDir $(<) misplaced!" ;
			}

			# We'll remember the relative (UP/DOWN) path that
			# got us here, plus any hard ROOT starting point
			# for the UP/DOWN.  If TOP is never set externally,
			# ROOT will always be "" (directory of jam's invocation).

			$(_top)-UP = $(SUBDIR_UP) $(_tokens) ;
			$(_top)-DOWN = $(SUBDIR_DOWN) ;
			$(_top)-ROOT = $(SUBDIR_ROOT:E="") ;
			$(_top) = [ FSubDirPath $(_top) ] ;
			$(_top) = $($(_top):R=$(CWD)) ;

			$(_top)-ROOT = $($(_top)) ;
			$(_top)-UP = ;
			$(_top)-DOWN = ;
	    }

	    # Set subdir vars for the inclusion of the Jamrules,
	    # just in case they have SubDir rules of their own.
	    # Note that SUBDIR_DOWN is empty: it's all the way
	    # up where the Jamrules live.  These gets overrided
	    # just after the inclusion.

	    SUBDIR_UP = $($(_top)-UP) ;
	    SUBDIR_DOWN = ;
	    SUBDIR_ROOT = $($(_top)-ROOT) ;

	    # Include $(TOPRULES) or $(TOP)/Jamrules.
	    # Include $(TOPRULES) if set.
	    # Otherwise include $(TOP)/Jamrules if present.

	    if $($(_top)RULES) {
			include $($(_top)RULES) ;
	    } else {
			NoCare $(JAMRULES:R=$($(_top)):G=$(_top)) ;
			include $(JAMRULES:R=$($(_top)):G=$(_top)) ;
			NoCare @($(_top).jamrules:R=$($(_top)):G=$(_top)) ;
			include @($(_top).jamrules:R=$($(_top)):G=$(_top)) ;
	    }
	}

	# Get path from $(TOP) to named directory.
	# Save dir tokens for other potential uses.

	SUBDIR_UP = $($(_top)-UP) ;
    SUBDIR_DOWN = $($(_top)-DOWN) $(_tokens) ;
	SUBDIR_ROOT = $($(_top)-ROOT) ;
    SUBDIR_TOKENS = $(SUBDIR_DOWN) ;

	SUBDIR = [ FSubDirPath $(<) ] ;

	# Now set up SEARCH_SOURCE, LOCATE_TARGET, SOURCE_GRIST
	# These can be reset if needed.	 For example, if the source
	# directory should not hold object files, LOCATE_TARGET can
	# subsequently be redefined.

	local target = /$(>) ;

	SEARCH_SOURCE = $(SUBDIR) ;
	LOCATE_SOURCE = [ FDirName $(ALL_LOCATE_TARGET) $(SUBDIR_DOWN) ] ;
	LOCATE_SOURCE = $(LOCATE_SOURCE)$(target:E=) ;
	LOCATE_TARGET = [ FDirName $(ALL_LOCATE_TARGET) $(SUBDIR_DOWN) ] ;
	LOCATE_TARGET = $(LOCATE_TARGET)$(target:E=) ;
	SOURCE_GRIST = [ FGrist $(ALL_SUBDIR_TOKENS) ] ;
	SOURCE_GRIST = $(SOURCE_GRIST)$(target:E=) ;
	## LOCAL CHANGE -- OPT_HEADER_CACHE_EXT.  With the header
	# cache, we can grist all files found during a header scan
	# without incurring a performance penalty.
	#
	HDRGRIST = $(SOURCE_GRIST) ;
	#
	## LOCAL CHANGE

	# Reset per-directory ccflags, hdrs, etc,
	# listed in SUBDIRRESET.
	# Note use of variable expanded assignment var

	SUBDIR$(SUBDIRRESET) = ;

	# Invoke user-specific SubDir extensions,
	# rule names listed in SUBDIRRULES.
	# Note use of variable expanded rule invocation

	$(SUBDIRRULES) $(<) ;
}

rule FSubDirPath
{
	# FSubDirPath TOP d1 ... ;

	# Returns path to named directory.

	# If jam is invoked in a subdirectory of the TOP, then we
	# need to prepend a ../ for every level we must climb up
	# (TOP-UP), and then append the directory names we must
	# climb down (TOP-DOWN), plus the named directories d1 ...
	# If TOP was set externally, or computed from another TOP
	# that was, we'll have to reroot the whole thing at TOP-ROOT.

	local _r = [ FRelPath $($(<[1])-UP) : $($(<[1])-DOWN) $(<[2-]) ] ;

	return $(_r:R=$($(<[1])-ROOT)) ;
}

rule SubDirCcFlags
{
	SUBDIRCCFLAGS += $(<) ;
}

rule SubDirC++Flags
{
	SUBDIRC++FLAGS += $(<) ;
}

rule SubDirHdrs
{
	SUBDIRHDRS += [ FDirName $(<) ] ;
}

rule SubInclude
{
	# SubInclude TOP d1 ... ;
	#
	# Include a subdirectory's Jamfile.

	# We use SubDir to get there, in case the included Jamfile
	# either doesn't have its own SubDir (naughty) or is a subtree
	# with its own TOP.
	if ! $($(<[1]))
	{
	    Exit SubInclude $(<[1]) without prior SubDir $(<[1]) ;
	}

	local jamfile ;
	if $(>)
	{
		jamfile = $(>:S=.jam) ;
	}
	else
	{
		jamfile = $(JAMFILE) ;
	}

	local include_marker = included_$(<:J=_)_$(jamfile) ;
	if $($(include_marker))
	{
		return ;
	}
	$(include_marker) = true ;

	local saveTokens = $(ALL_SUBDIR_TOKENS) ;
	local saveCurrentJamfile = $(CURRENT_JAMFILE) ;
	SubDir $(<) ;

	CURRENT_JAMFILE = $(jamfile:D=$(SUBDIR)) ;
	include $(CURRENT_JAMFILE) ;

	if $(saveTokens)
	{
		SubDir $(saveTokens) ;
		CURRENT_JAMFILE = $(saveCurrentJamfile) ;
	}
}

rule SubRules
{
	# SubRules TOP d1 ... : Other-TOP ;
	#
	# Read another tree's Jamrules, by giving it's path according
	# to this tree and it's own name.

	if ! $($(<[1]))
	{
	    Exit SubRules $(<[1]) without prior SubDir $(<[1]) ;
	}

	SubDir $(<) ;
	SubDir $(>) ;
}

#
# Utility rules; no side effects on these
#

rule FGrist
{
	return $(<:J=!) ;

}

rule FGristFiles
{
	return $(<:G=$(SOURCE_GRIST:E)) ;
}

rule FReverse
{
	# FReverse a1 a2 a3 ... ;
	# return ... a3 a2 a1 ;

	if $(1) { return [ FReverse $(1[2-]) ] $(1[1]) ; }
}

rule FSubDir
{
	# If $(>) is the path to the current directory, compute the
	# path (using ../../ etc) back to that root directory.
	# Sets result in $(<)

	if ! $(<[1])
	{
	    return $(DOT) ;
	}
	else
	{
	    local _i _d ;

	    _d = $(DOTDOT) ;

	    for _i in $(<[2-])
	    {
		_d = $(_d:R=$(DOTDOT)) ;
	    }

	    return $(_d) ;
	}
}

rule FStripCommon
{
	# FStripCommon v1 : v2 ;

	# Strip common initial elements of variables v1 and v2.
	# Modifies the variable values themselves.

	if $($(<)[1]) && $($(<)[1]) = $($(>)[1])
	{
	    $(<) = $($(<)[2-]) ;
	    $(>) = $($(>)[2-]) ;
	    FStripCommon $(<) : $(>) ;
	}
}

rule FRelPath
{
	local _l _r ;

	# first strip off common parts

	_l = $(<) ;
	_r = $(>) ;

	FStripCommon _l : _r ;

	# now make path to root and path down

	_l = [ FSubDir $(_l) ] ;
	_r = [ FDirName $(_r) ] ;

	# Concatenate and save

	# XXX This should be better

	if $(_r) = $(DOT) {
	    return $(_l) ;
	} else {
	    return $(_r:R=$(_l)) ;
	}
}

#
# Operating system specific utility rules
# First, the (generic) UNIX versions
#

rule FQuote { return \\\"$(<)\\\" ; }
rule FDefines { return -D$(<) ; }
rule FIncludes { return -I$(<) ; }
rule FLibraryPaths { return -L$(<) ; }

rule FDirName
{
	# Turn individual elements in $(<) into a usable path.

	local _i ;
	local _s = $(DOT) ;

	for _i in $(<)
	{
	    _s = $(_i:R=$(_s)) ;
	}

	return $(_s) ;
}

if $(MSVCNT)
{
	rule FDefines { return /D$(<) ; }
	rule FIncludes { return /I"\"$(<)\"" ; }
	rule FLibraryPaths { return \"/LIBPATH:$(<)\" ; }
}

#
# Actions
#

#
# First the defaults
#

actions updated together piecemeal Archive
{
	$(AR) $(LIBFLAGS) $(<) $(>)
}

actions piecemeal together existing Clean
{
	$(RM) $(>)
}

if $(NT)
{
	actions piecemeal together existing Clean
	{
	$(RM) "$(>:\\)"
	}
}

actions Link
{
	"$(LINK)" $(LINKFLAGS) -o $(<[1]) $(UNDEFS) $(>) $(NEEDLIBS:T) $(LINKLIBS)
}

actions quietly MkDir1
{
	$(MKDIR) "$(<)"
}

if $(NT)
{
	actions quietly MkDir1
	{
		if not exist "$(<:\\)" $(MKDIR) "$(<:\\)"
	}
}

actions together Ranlib
{
	$(RANLIB) $(<)
}

actions quietly updated piecemeal together RmTemps
{
	$(RM) $(>)
}

if $(NT)
{
	actions quietly updated piecemeal together RmTemps
	{
	$(RM) "$(>:\\)"
	}
}

#
# NOARUPDATE - can't update an archive
#

if $(NOARUPDATE)
{
	actions Archive
	{
	$(AR) $(LIBFLAGS) $(<) $(>)
	}
}

#
# UNIX specific actions
#

if $(UNIX)
{
}

#
# NT specific actions
#

if $(NT) && $(MSVCNT)
{
	actions together piecemeal Archive
	{
	if exist $(<) set _$(<:B)_=$(<)
	$(AR) $(LIBFLAGS) /out:$(<) %_$(<:B)_% $(>)
	}

	actions piecemeal together existing Clean
	{
		$(RM) "$(>:\\)"
	}

	actions RegSvr32
	{
	regsvr32 /s /c "$(1)"
	}

	actions existing UnRegSvr32
	{
	regsvr32 /s /u "$(2)"
	}

	if $(COMPILER) = vc6
	{
		actions response LinkDebug
		{
		set PATH=%PATH%;$(MSVCBIN);$(MSVCNT_PATH);$(LINK_PATHS:E)
		SET INCLUDE=$(STDHDRS:\\J=;)
		"$(LINK:\\)" /nologo /out:$(<[1]) $(UNDEFS) @@($(LINKFLAGS) $(>) $(NEEDLIBS:T) "$(LINKLIBS)")
		}

		actions response Link
		{
		set PATH=%PATH%;$(MSVCBIN);$(MSVCNT_PATH);$(LINK_PATHS:E)
		SET INCLUDE=$(STDHDRS:\\J=;)
		"$(LINK:\\)" /nologo /out:$(<[1]) $(UNDEFS) @@($(LINKFLAGS) $(>) $(NEEDLIBS:T) "$(LINKLIBS)")
		}
	}
	else
	{
		actions response LinkDebug
		{
		set PATH=%PATH%;$(MSVCBIN);$(MSVCNT_PATH);$(LINK_PATHS:E)
		SET INCLUDE=$(STDHDRS:\\J=;)
		"$(LINK:\\)" /nologo /out:$(<[1]) $(UNDEFS) @@($(LINKFLAGS) $(>) $(NEEDLIBS:T) "$(LINKLIBS)")
		if exist $(MANIFEST).intermediate.manifest "$(MT:\\)" -nologo -notify_update -manifest $(MANIFEST).intermediate.manifest -out:$(MANIFEST).embed.manifest &
		if "%ERRORLEVEL%" == "1090650113" echo $(MANIFEST_TYPE) 24 "$(MANIFEST).embed.manifest" > "$(MANIFEST).embed.rc" &
		"$(RC:\\)" /fo $(MANIFEST).embed.res $(MANIFEST).embed.rc &
		"$(LINK:\\)" /nologo /out:$(<[1]) $(UNDEFS) @@($(LINKFLAGS) $(>) $(NEEDLIBS:T) "$(LINKLIBS)")
		}

		actions response LinkNoManifest
		{
		set PATH=%PATH%;$(MSVCBIN);$(MSVCNT_PATH);$(LINK_PATHS:E)
		SET INCLUDE=$(STDHDRS:\\J=;)
		"$(LINK:\\)" /nologo /out:$(<[1]) $(UNDEFS) @@($(LINKFLAGS) $(>) $(NEEDLIBS:T) "$(LINKLIBS)")
		}

		actions response Link
		{
		set PATH=%PATH%;$(MSVCBIN);$(MSVCNT_PATH);$(LINK_PATHS:E)
		SET INCLUDE=$(STDHDRS:\\J=;)
		"$(LINK:\\)" /nologo /out:$(<[1]) $(UNDEFS) @@($(LINKFLAGS) $(>) $(NEEDLIBS:T) "$(LINKLIBS)")
		"$(MT:\\)" -nologo -manifest $(MANIFEST).intermediate.manifest -outputresource:$(<[1]);$(MANIFEST_TYPE)
		}
	}

}

if $(WIN98)
{
    actions existing Clean
    {
	del $(>)
    }
}


#
# Mac OS X specific actions
#

if $(OS) = MACOSX {
	actions response Link
	{
		"$(LINK)" $(LINKFLAGS) -o "$(<[1])" $(UNDEFS) -filelist @($(>:J=$(NEWLINE))) $(NEEDLIBS:T) $(LINKLIBS)
	}
}

########################################################################
# The original MultiCppCompile rule was provided by Alen Ladavac.
########################################################################

# Used to group files from a list by some bound variable.
# Files with first value of the variable are returned as results, and removed from the input list.
# NOTE: _filelist and _varname are passed by reference!
# [ GroupByVar1 _filelist : _varname [: maxPerGroup] ]
rule GroupByVar1
{
	# get the actual filelist
	local _all = $($(1)) ;

	# get value of the variable on the first file
	local _var1 ;
	on $(_all[1]) _var1 = $($(2)) ;

	local _group1 = ;
	local _rest = ;
	local _f ;

	if $(3)
	{
		local _count = 0 ;
		local _done ;
		for _f in $(_all) {
			local _var ;
			on $(_f) _var = $($(2)) ;
			if ! $(_done) && ( $(_var) in $(_var1) ) && ( $(_var1) in $(_var) )  {
				_group1 += $(_f) ;
				_count = [ Math $(_count) + 1 ] ;
				if $(_count) = $(3)
				{
					_done = true ;
				}
			} else {
				_rest += $(_f) ;
			}
		}
		$(1) = $(_rest) ;
		return $(_group1) ;
	}

	for _f in $(_all) {
		local _var ;
		on $(_f) _var = $($(2)) ;
		if ( $(_var) in $(_var1) ) && ( $(_var1) in $(_var) )  {
			_group1 += $(_f) ;
		} else {
			_rest += $(_f) ;
		}
	}
	$(1) = $(_rest) ;
	return $(_group1) ;
}


rule BatchCompileGroupSize TARGET : SIZE
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	BATCH_COMPILE_GROUP_SIZE on $(TARGET) = $(SIZE) ;
}


#---------------------------------------------------------------------
# OBJECTS = MultiCppCompile $(sources) ;
#
#   This rule will compile $(sources), and will return  the result objects.
#
#---------------------------------------------------------------------
# Set this if you want object files to be put in subdirs matching dir hierarchy of source files.
# Otherwise, all object files are put in one flat directory per project.
rule CppCompileOptions OPTIONS
{
	if outputastree in $(OPTIONS)
	{
		__MultiCppCompile_OutputAsTree = 1 ;
	}
}


__MultiCppCompile_OutputAsTree = 0 ;

BUILD_EXTENSIONS = $(SUFOBJ) ;

rule AddBuildExtensions TYPE : EXTS : RULE : SUFOBJ : ADD_TO_EXTENSIONS : ADD_TO_LINK
{
	if $(ADD_TO_EXTENSIONS) = 1 {
		BUILD_EXTENSIONS += $(EXTS) ;
	}
	BUILD_EXTENSIONS.$(TYPE) += $(EXTS) ;
	BUILD$(EXTS).RULE = $(RULE) ;
	BUILD$(EXTS).TYPE = $(TYPE) ;
	BUILD$(EXTS).COMPILER = $(TYPE) ;
	BUILD$(EXTS).PREFLAGS = pre$(TYPE)FLAGS ;
	BUILD$(EXTS).FLAGS = $(TYPE)FLAGS ;
	BUILD$(EXTS).SUBDIRFLAGS = SUBDIR$(TYPE)FLAGS ;
	BUILD$(EXTS).SUFOBJ = $(SUFOBJ) ;
	BUILD$(EXTS).ADD_TO_LINK = $(ADD_TO_LINK) ;
	BUILD$(EXTS).PCHFLAGS = PCH$(TYPE)FLAGS ;
}

AddBuildExtensions CC : .c .s : CC : $(SUFOBJ) "" : 1 : 1 ;
AddBuildExtensions M : .m : CC : $(SUFOBJ) "" : 1 : 1 ;
AddBuildExtensions C++ : .cc .cpp .cxx : C++ : $(SUFOBJ) "" : 1 : 1 ;
AddBuildExtensions MM : .mm : C++ : $(SUFOBJ) "" : 1 : 1 ;
AddBuildExtensions PCH : .h : PCH : "" .gch : 0 : 0 ;

if $(MSVCNT)
{
	BUILD_EXTENSIONS += .res ;
}

rule MultiCppCompile TARGET : SOURCES
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;

	local grist = $(TARGET) ;

	#
	# Pass 1: Bind final flags to each file
	#

	local _postmflags ;

	if $(MSVCNT)
	{
		switch $(COMPILER)
		{
			case vc6 	: _VCPDB = vc60 ;
			case vs2002 : _VCPDB = vc70 ;
			case vs2003 : _VCPDB = vc70 ;
			case vs2005 : _VCPDB = vc80 ;
			case vs2008 : _VCPDB = vc90 ;
			case vs2010 : _VCPDB = vc90 ;
		}

		local vcidb = $(_VCPDB:G=$(grist):S=.idb) ;
		_VCPDB = $(_VCPDB:G=$(grist):S=.pdb) ;
		MakeLocate $(vcidb) $(_VCPDB) : $(LOCATE_TARGET) ;

		Clean clean:$(TARGET) : $(_VCPDB) $(vcidb) ;

		if $(__MultiCppCompile_OutputAsTree) = 0 {
			local combinedLocateTarget = [ FDirName $(LOCATE_TARGET) ] ;
			_postmflags = "/c \"/Fo$(combinedLocateTarget:\\)\\\\\" \"/Fd$(_VCPDB:T)\"" ;
		}
	}

	local ALL_TYPES =
			$(PLATFORM).$(CONFIG)
			*.$(CONFIG)
			$(PLATFORM).*
			*.*
	;

	local postHDRS ;
	local postREFERENCEDIRECTORIES ;
	local preDEFINES ;
	local preCCFLAGS ;
	local preC++FLAGS ;
	local preMFLAGS ;
	local preMMFLAGS ;
	local flagsToRemove ;
	local flagsToAdd ;

	on * {
		postHDRS += $(HDRS.$(ALL_TYPES)) ;
		if $(MSVCNT) {
			local flags = /I /AI ;
			postREFERENCEDIRECTORIES += $(flags)\"$(REFERENCEDIRECTORIES.$(ALL_TYPES))\" ;
		}
		preDEFINES += $(DEFINES.$(ALL_TYPES)) ;
		preCCFLAGS += $(CCFLAGS.$(ALL_TYPES)) ;
		preC++FLAGS += $(C++FLAGS.$(ALL_TYPES)) ;
		preMFLAGS += $(MFLAGS.$(ALL_TYPES)) ;
		preMMFLAGS += $(MMFLAGS.$(ALL_TYPES)) ;
		flagsToRemove += $(FLAGS_TO_REMOVE.$(ALL_TYPES)) ;
		flagsToAdd += $(FLAGS_TO_ADD.$(ALL_TYPES)) ;
	}

	on $(TARGET) {
		postHDRS = $(HDRS.$(ALL_TYPES)) $(postHDRS) ;
		if $(MSVCNT) {
			local flags = /I /AI ;
			postREFERENCEDIRECTORIES = $(flags)\"$(REFERENCEDIRECTORIES.$(ALL_TYPES))\" $(postREFERENCEDIRECTORIES) ;
		}
		preDEFINES += $(DEFINES.$(ALL_TYPES)) ;
		preCCFLAGS += $(CCFLAGS.$(ALL_TYPES)) ;
		preC++FLAGS += $(C++FLAGS.$(ALL_TYPES)) ;
		preMFLAGS += $(MFLAGS.$(ALL_TYPES)) ;
		preMMFLAGS += $(MMFLAGS.$(ALL_TYPES)) ;
		flagsToRemove += $(FLAGS_TO_REMOVE.$(ALL_TYPES)) ;
		flagsToAdd += $(FLAGS_TO_ADD.$(ALL_TYPES)) ;
	}

	preDEFINES = [ FDefines $(preDEFINES) ] ;

	# start with empty list of all generated objects
	local _allobjs = ;

	# for each file
	local dollar = $ ;
	local colon = ":" ;
	local listIncludes = @(I=\\$(BUILD_EXTENSIONS)$:J=$(colon)) ;
	local sources = @($(dollar)(SOURCES$(colon)$(listIncludes)):A:G=$(grist)) ;

	# source needs to be scanned for header dependencies
	HDRRULE on $(sources) = HdrRule ;
	HDRSCAN on $(sources) = $(HDRPATTERN) ;
	HDRGRIST on $(sources) = $(grist) ;

	SEARCH on $(sources) = $(SEARCH_SOURCE) ;

	local newsrcs ;
	local _src ;

	for _src in $(sources) {
		on $(_src) if $(EXCLUDED_FROM_BUILD) = true {
			continue ;
		}

		local ext = $(_src:S) ;
		local BUILD_EXT = BUILD$(ext) ;
		if ! $($(BUILD_EXT).RULE) {
			_allobjs += $(_src) ;
			continue ;
		}

		if $(COMPILER) in mingw gcc
		{
			# if the source should create pch
			local _pch ;
			on $(_src) _pch = $(PCH) ;
			if $(_pch[4]) {
				local _pchName = @($(_pch[3]:LBS):G=$(grist)) ;
				newsrcs += $(_pchName) ;

				local _pchFilename = $(_pchName).gch ;
				PCHFLAGS.$(PLATFORM).$(CONFIG) on $(_pchFilename) += $($($(BUILD_EXT).PCHFLAGS)) ;

#				Depends $(_pchFilename) : $(_src) ;
			}
		}

		newsrcs += $(_src) ;
	}

	for _src in $(newsrcs) {
		local ext = $(_src:S) ;
		local BUILD_EXT = BUILD$(ext) ;

		local sufobj = $($(BUILD_EXT).SUFOBJ) ;

		local _obj ;
		if $(__MultiCppCompile_OutputAsTree) != 0 {
			if $(sufobj[1]) {
				_obj = $(_src:S=$(sufobj[1]))$(sufobj[2]) ;
			} else {
				_obj = $(_src)$(sufobj[2]) ;
			}
			_obj = [ Subst $(_obj) : %.%. : __ ] ;
			_obj = [ Subst $(_obj) : \: : -- ] ;
			local _objdir = $(_obj:DR=$(LOCATE_TARGET)) ;
			MakeLocate $(_obj) : $(_objdir) ;
			BINDING on $(_obj) = $(_obj:BS) ;
			_postmflags = "/c \"/Fo$(_objdir:\\)\\\\\" \"/Fd$(_VCPDB:T)\"" ;
		} else {
			if $(sufobj[1]) {
				_obj = $(_src:S=$(sufobj[1]):D=)$(sufobj[2]) ;
			} else {
				_obj = $(_src)$(sufobj[2]) ;
			}
			MakeLocate $(_obj) : $(LOCATE_TARGET) ;
		}

		local _hdrs = $(SEARCH_SOURCE) ;
		on $(_obj) _hdrs += $(HDRS.$(ALL_TYPES)) ;
		_hdrs += $(postHDRS) ;

		HDRSEARCH on $(_src) = $(_hdrs) ;

		# Rest
		Depends $(_obj) : $(_src) ;

		$($(BUILD_EXT).COMPILER) on $(_obj) = $($($(BUILD_EXT).COMPILER)) ;

		local _flags = $($($(BUILD_EXT).PREFLAGS)) ;
		on $(_obj) _flags += $($($(BUILD_EXT).FLAGS).$(ALL_TYPES)) ;
		_flags += $($($(BUILD_EXT).SUBDIRFLAGS)) ;

		# if the source should create pch
		local _nopch ;
		local _pch ;
		on $(_src) {
			_nopch = $(NOPCH) ;
			_pch = $(PCH) ;
		}
		if $(_pch) {
			_flags += -I $(LOCATE_SOURCE) ;
		}

		_flags += [ FIncludes . $(_hdrs) ] ;

		_flags += $(preDEFINES) ;
		on $(_obj) _flags += [ FDefines $(DEFINES.$(ALL_TYPES)) ] ;

		# now that general flags on the file are determined

		if $(MSVCNT) {
			_flags += $(postREFERENCEDIRECTORIES) ;

			if $(_pch[4]) {
				# add extra flags to enable pch creation
				local _pchFilename = $(_pch[3]:LBS).pch ;
				local _pchDiskFilename = [ FDirName $(LOCATE_TARGET) $(_pchFilename:BS) ] ;
				_flags += /Fp$(_pchDiskFilename:\\) ;  # pch file
				_flags += /Yc$(_pch[2]) ;  # h file
				# mark that it will be created by compilation through srcref
				_pchFilename = $(_pchFilename:G=$(grist)) ;
				BINDING on $(_pchFilename) = $(_pchFilename:BS) ;
				MakeLocate $(_pchFilename) : $(LOCATE_TARGET) ;
				Depends $(_pchFilename) : $(_src) ;
				Clean clean:$(TARGET) : $(_pchFilename) ;

			# if the source should use pch
			} else if $(_pch[2]) && ! $(_nopch) {
				# add extra flags to enable pch loading
				local _pchFilename = $(_pch[3]:LBS).pch ;
				local _pchDiskFilename = [ FDirName $(LOCATE_TARGET) $(_pchFilename:BS) ] ;
				_flags += /Fp$(_pchDiskFilename:\\) ;  # pch file
				_flags += /Yu$(_pch[2]) ;  # h file
				# mark that compilation will depend on it
				_pchFilename = $(_pchFilename:G=$(grist)) ;
				Includes $(_src) : $(_pchFilename) ;
			}

			# bind flags, defines and includes to the target
			_flags += $(_postmflags) ;
		}
		else if $(COMPILER) in mingw gcc
		{
			if $(_pch)  &&  ! $(_nopch) {
				local _pchName = @($(_pch[3]:LBS):G=$(grist)) ;
				local _pchFilename = $(_pchName).gch ;

				# if the source should use pch
				if $(_pch[2]) {
					# mark that compilation will depend on it
					Includes $(_src) : $(_pchFilename) ;
				}
			}

			_flags += "-c -o \"$(_obj:T)\"" ;
		}

		_flags -= $(flagsToRemove) ;
		_flags += $(flagsToAdd) ;
		MFLAGS on $(_src) = $(BUILD$(ext).RULE) $(sufobj) $(BUILD$(ext).ADD_TO_LINK) $(_flags) ;
		UseCommandLine $(_obj) : $(_flags) ;
	}

	#
	# Pass 2: Compile in batches, grouped by flags that were bound in previous pass
	#

	local batchCompileGroupSize ;
	on $(TARGET) batchCompileGroupSize = $(BATCH_COMPILE_GROUP_SIZE) ;
	if ! $(batchCompileGroupSize)
	{
		on * batchCompileGroupSize = $(BATCH_COMPILE_GROUP_SIZE) ;
	}

	# for each batch, grouped by final flags
	while $(newsrcs) {
		_sources = [ GroupByVar1 newsrcs : MFLAGS : $(batchCompileGroupSize) ] ;

		local _pch1 ;
		local sufobj ;
		local addToLink ;
		on $(_sources[1]) {
			_pch1 = $(PCH) ;
			sufobj = $(MFLAGS[2]) $(MFLAGS[3]) ;
			addToLink = $(MFLAGS[4]) ;
		}

		# start with empty lists of objects for this batch
		local objects ;
		if $(__MultiCppCompile_OutputAsTree) != 0 {
			if $(sufobj[1]) {
				objects = $(_sources:S=$(sufobj[1]))$(sufobj[2]) ;
			} else {
				objects = $(_sources)$(sufobj[2]) ;
			}
			objects = [ Subst $(objects) : %.%. : __ ] ;
			objects = [ Subst $(objects) : \: : -- ] ;
		} else {
			if $(sufobj[1]) {
				objects = $(_sources:S=$(sufobj[1]):D=)$(sufobj[2]) ;
			} else {
				objects = $(_sources)$(sufobj[2]) ;
			}
		}

		if $(addToLink) = 1 {
			# collect produced objects (note that this is before adding the pch,
			# because we don't want to use it in linking)
			_allobjs += $(objects) ;
		}

		# if this batch will also create a pch
		if $(MSVCNT) {
			if $(_pch1[4]) {
				local _pchFilename = $(_pch1[3]:LBS).pch ;
				_pchFilename = $(_pchFilename:G=$(grist)) ;
				Depends $(objects) : $(_pchFilename) ;
				# add that pch as output
				objects += $(_pchFilename) ;
			}
		}
		else if $(COMPILER) in mingw gcc {
			if $(_pch1[3]) {
				local _pchName = @($(_pch[3]:LBS):G=$(grist)) ;
				local _pchFilename = $(_pchName).gch ;
				Depends $(objects) : $(_pchFilename) ;
			}
		}

		# mark all objects (and pch) for cleaning
		Clean clean:$(TARGET) : $(objects) ;

		local flags ;
		on $(_sources[1]) flags = $(MFLAGS) ;
		MFLAGS on $(objects) = $(flags[5-]) ;

		if $(MSVCNT) {
			SEMAPHORE on $(objects) = $(_VCPDB) ;
		}

		$(flags[1]) $(objects) : $(_sources) ;
	}

	# return all produced objects
	return $(_allobjs) ;
}

if $(MSVCNT)
{
	actions updated response CC
	{
		PATH=$(MSVCNT_PATH);%PATH%
		SET INCLUDE=$(STDHDRS:\\J=;)
		"$(CC:\\)" /nologo @@($(MFLAGS) "$(>)")
	}

	actions updated response C++
	{
		PATH=$(MSVCNT_PATH);%PATH%
		SET INCLUDE=$(STDHDRS:\\J=;)
		"$(C++:\\)" /nologo @@($(MFLAGS) "$(>)")
	}

	actions together response Archive
	{
	PATH=%PATH%;$(MSVCNT_PATH)
	"$(AR)" /nologo $(LIBFLAGS) /out:"$(<)" @@("$(>:\\)")
	}
}

if $(COMPILER) in mingw gcc
{
	actions updated response CC
	{
		"$(CC)" -c $(MFLAGS) $(>)
	}

	actions updated response C++
	{
		"$(C++)" -c $(MFLAGS) $(>)
	}

	actions updated response PCH
	{
		"$(C++)" -c $(MFLAGS) $(>)
	}
}

########################################################################
########################################################################

rule Lump PARENT : SOURCES_VARIABLE_NAME : LUMP_NAME : PCH_HEADER :
		PCH_HEADER_FILENAME : LUMP_EXT : EXTRA_INCLUDE_PATHS
{
	if $(LUMP) = 0
	{
		return ;
	}

	PARENT = [ _retrieveActiveTargetName $(PARENT) ] ;
	local grist = $(PARENT) ;

	LUMP_EXT ?= cpp ;

	local contents = "// This lump file is a generated file.  Do not modify.$(NEWLINE)" ;
	local line ;
	local PCH_SOURCE_FILENAME ;
	if $(PCH_HEADER)
	{
		PCH_SOURCE_FILENAME = $(PCH_HEADER).$(LUMP_EXT) ;
		PCH_HEADER_FILENAME ?= $(PCH_HEADER).h ;
		line = "#include \"$(PCH_HEADER_FILENAME)\"$(NEWLINE)" ;
		contents = $(contents)$(line) ;
	}

	local file ;
	for file in $($(SOURCES_VARIABLE_NAME))
	{
		if [ on $(file:G=$(grist)) Var EXCLUDED_FROM_BUILD ] = true {
			continue ;
		}
		if $(file:S) in $(BUILD_EXTENSIONS.CC) $(BUILD_EXTENSIONS.C++)  &&  $(file) != $(PCH_SOURCE_FILENAME)
		{
			line = "#include \"$(file)\"$(NEWLINE)" ;
			contents = $(contents)$(line) ;
		}
	}

	contents = $(contents)$(NEWLINE) ;

	local gristedFileName = @(!$(LUMP_NAME)!.$(LUMP_EXT):G=$(grist)) ;
	MakeLocate $(gristedFileName) : $(LOCATE_SOURCE) ;
	Clean clean:$(PARENT) : $(gristedFileName) ;

	$(SOURCES_VARIABLE_NAME) = $(PCH_SOURCE_FILENAME) $(gristedFileName) ;

	local subdir = $(SUBDIR[1]:R=$(CWD)) ;
	ObjectIncludeDirectories $(gristedFileName) : $(subdir) ;
	if $(EXTRA_INCLUDE_PATHS)
	{
		ObjectIncludeDirectories $(gristedFileName) : $(EXTRA_INCLUDE_PATHS) ;
	}

	if [ MD5 $(contents) ] != [ MD5File $(gristedFileName) ]
	{
		CONTENTS on $(gristedFileName) = $(contents) ;
		Always $(gristedFileName) ;
		MakeLump $(gristedFileName) ;
	}
}

actions MakeLump
{
	^^($(1)|$(CONTENTS))
}


########################################################################
########################################################################

rule _retrieveActiveTargetName TARGETS
{
	return $(TARGETS:E=$(ACTIVE_PROJECT:E="")) ;
}

rule _retrieveVar VARIABLE : TARGET : THE_CONFIG : THE_PLATFORM
{
	THE_CONFIG ?= $(CONFIG) ;
	THE_PLATFORM ?= $(PLATFORM) ;

	# Fastest
	on $(TARGET) return $($(VARIABLE).$(THE_PLATFORM).$(THE_CONFIG))
			$($(VARIABLE).*.$(THE_CONFIG))
			$($(VARIABLE).$(THE_PLATFORM).*)
			$($(VARIABLE).*.*) ;

#	return
#		[ on $(TARGET) MultiVar
#				$(VARIABLE).$(THE_PLATFORM).$(THE_CONFIG)
#				$(VARIABLE).*.$(THE_CONFIG)
#				$(VARIABLE).$(THE_PLATFORM).*
#				$(VARIABLE).*.* ] ;

#	return
#		[ on $(TARGET) Var $(VARIABLE).$(THE_PLATFORM).$(THE_CONFIG) ]
#		[ on $(TARGET) Var $(VARIABLE).*.$(THE_CONFIG) ]
#		[ on $(TARGET) Var $(VARIABLE).$(THE_PLATFORM).* ]
#		[ on $(TARGET) Var $(VARIABLE).*.* ] ;
}


rule _retrieveOutputPath TARGET : THE_CONFIG : THE_PLATFORM
{
	THE_CONFIG ?= $(CONFIG) ;
	THE_PLATFORM ?= $(PLATFORM) ;
	local outputPath = [ on $(TARGET) SearchVar
			LOCATE.$(THE_PLATFORM).$(THE_CONFIG)
			LOCATE.*.$(THE_CONFIG)
			LOCATE.$(THE_PLATFORM).*
			LOCATE.*.* ] ;
	if ! $(outputPath)
	{
		outputPath = [ on * SearchVar
				LOCATE.$(THE_PLATFORM).$(THE_CONFIG)
				LOCATE.*.$(THE_CONFIG)
				LOCATE.$(THE_PLATFORM).*
				LOCATE.*.* : $(LOCATE_TARGET) ] ;
	}
	return $(outputPath) ;
}


rule _retrieveOutputName TARGET : SUFFIX_NAME : THE_CONFIG : THE_PLATFORM
{
	THE_CONFIG ?= $(CONFIG) ;
	THE_PLATFORM ?= $(PLATFORM) ;
	local target = [ on $(TARGET) SearchVar
			OUTPUTNAME.$(THE_PLATFORM).$(THE_CONFIG)
			OUTPUTNAME.*.$(THE_CONFIG)
			OUTPUTNAME.$(THE_PLATFORM).*
			OUTPUTNAME.*.*
			: $(TARGET) ] ;

	local presuffix = [ on $(TARGET) SearchVar
			OUTPUTPOSTFIX.$(THE_PLATFORM).$(THE_CONFIG)
			OUTPUTPOSTFIX.*.$(THE_CONFIG)
			OUTPUTPOSTFIX.$(THE_PLATFORM).*
			OUTPUTPOSTFIX.*.* ] ;
	presuffix ?= [ on * SearchVar
			OUTPUTPOSTFIX.$(THE_PLATFORM).$(THE_CONFIG)
			OUTPUTPOSTFIX.*.$(THE_CONFIG)
			OUTPUTPOSTFIX.$(THE_PLATFORM).*
			OUTPUTPOSTFIX.*.* ] ;
	presuffix ?= .$(THE_CONFIG) ;
	if $(presuffix) = *off*
	{
		presuffix = ;
	}

	local suffix = [ on $(TARGET) SearchVar
			OUTPUTSUFFIX.$(THE_PLATFORM).$(THE_CONFIG)
			OUTPUTSUFFIX.*.$(THE_CONFIG)
			OUTPUTSUFFIX.$(THE_PLATFORM).*
			OUTPUTSUFFIX.*.*
			$(SUFFIX_NAME).$(THE_PLATFORM)
			$(SUFFIX_NAME).*
			$(SUFFIX_NAME) ] ;

	return $(target)$(presuffix:E=)$(suffix:E=) ;
}


########################################################################
########################################################################

actions quietly WriteFile
{
	^^($(1)|$(CONTENTS))
}

rule _writeManifest TARGET : _t : MANIFEST_TYPE
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;

	local tempIntermediateManifest = @($(_t[1]).intermediate.manifest:G=$(grist)) ;
	MakeLocate $(tempIntermediateManifest) : $(LOCATE_TARGET) ;
	Clean clean:$(TARGET) : $(tempIntermediateManifest) ;

	if $(CONFIG) = debug
	{
		local tempEmbeddedManifest = @($(_t[1]).embed.manifest:G=$(grist)) ;
		MakeLocate $(tempEmbeddedManifest) : $(LOCATE_TARGET) ;
		CONTENTS on $(tempEmbeddedManifest) =
"<?xml version='1.0' encoding='UTF-8' standalone='yes'?>
<assembly xmlns='urn:schemas-microsoft-com:asm.v1' manifestVersion='1.0'>
</assembly>
" ;
		WriteFile $(tempEmbeddedManifest) ;
		Clean clean:$(TARGET) : $(tempEmbeddedManifest) ;

		local tempEmbeddedRc = @($(_t[1]).embed.rc:G=$(grist)) ;
		Depends $(tempEmbeddedRc) : $(tempEmbeddedManifest) ;
		MakeLocate $(tempEmbeddedRc) : $(LOCATE_TARGET) ;
		CONTENTS on $(tempEmbeddedRc) =
			"$(MANIFEST_TYPE) /* CREATEPROCESS_MANIFEST_RESOURCE_ID */ 24 /* RT_MANIFEST */ \"$(LOCATE_TARGET)/$(_t[1]:G=).embed.manifest\"" ;
		WriteFile $(tempEmbeddedRc) ;
		Clean clean:$(TARGET) : $(tempEmbeddedRc) ;
		Depends $(tempEmbeddedRc) : $(tempEmbeddedManifest) ;

		local tempEmbeddedRes = [ ResourceCompiler $(TARGET) : $(tempEmbeddedRc) : quiet ] ;
		_s += $(tempEmbeddedRes) ;

		Depends $(_t[1]) : $(tempIntermediateManifest) $(tempEmbeddedRes) ;
		if $(_t[2])
		{
			Includes $(_t[2]) : $(tempIntermediateManifest) $(tempEmbeddedRes) ;
		}
	}

	MANIFEST_TYPE on $(_t) = $(MANIFEST_TYPE) ;
}


rule _linkManifest _t
{
	MANIFEST on $(_t) = "$(LOCATE_TARGET)/$(_t[1]:G=)" ;
}


########################################################################
########################################################################

rule Application TARGET : SOURCES : OPTIONS
{
	local objects = [ MultiCppCompile $(TARGET) : $(SOURCES) : $(TARGET) ] ;
	ApplicationFromObjects $(TARGET) : $(objects) : $(OPTIONS) ;
	ACTIVE_PROJECT = "" ;
}


rule ApplicationFromObjects TARGET : OBJECTS : OPTIONS
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	local _s = $(OBJECTS:G=$(grist)) ;
	local _t = [ _retrieveOutputName $(TARGET) : SUFEXE ] ;
	_t = $(_t:G=$(grist)) ;

	local outputPath = [ _retrieveOutputPath $(TARGET) ] ;

	local _linkTargets = $(_t) ;

	Depends all : $(TARGET) ;
	Depends $(TARGET) : $(_linkTargets) ;
	NotFile $(TARGET) ;
	Depends $(_linkTargets) : $(_s) ;
	MakeLocate $(_linkTargets) : $(outputPath) ;

	Depends clean : clean:$(TARGET) ;
	NotFile clean:$(TARGET) ;
	Always clean:$(TARGET) ;
	Depends allclean : allclean:$(TARGET) ;
	NotFile allclean:$(TARGET) ;
	Always allclean:$(TARGET) ;
	Depends allclean:$(TARGET) : clean:$(TARGET) ;
	Clean clean:$(TARGET) : $(_linkTargets) ;

	local linkFlags =
		[ FLibraryPaths [ _retrieveVar LINKDIRECTORIES : $(TARGET) : $(CONFIG) : $(PLATFORM) ] ]
		[ FLibraryPaths [ _retrieveVar LINKDIRECTORIES : * : $(CONFIG) : $(PLATFORM) ] ]
		[ _retrieveVar LINKFLAGS : $(TARGET) : $(CONFIG) : $(PLATFORM) ]
		[ _retrieveVar LINKFLAGS : * : $(CONFIG) : $(PLATFORM) ] ;

	if $(COMPILER) in vc6 vs2003 vs2005 vs2008 vs2010 {
		if windows in $(OPTIONS) {
			linkFlags += /SUBSYSTEM:WINDOWS ;
		} else {
			linkFlags += /SUBSYSTEM:CONSOLE ;
		}
	}

	local linkLibs =
		[ _retrieveVar LINKLIBS : $(TARGET) : $(CONFIG) : $(PLATFORM) ]
		[ _retrieveVar LINKLIBS : * : $(CONFIG) : $(PLATFORM) ] ;

	local needLibs =
		[ _retrieveVar NEEDLIBS : $(TARGET) : $(CONFIG) : $(PLATFORM) ]
		[ _retrieveVar NEEDLIBS : * : $(CONFIG) : $(PLATFORM) ] ;

	NEEDLIBS on $(_linkTargets) = $(needLibs) ;
	Depends $(_linkTargets) : $(needLibs) ;

	if $(MSVCNT) {
	    # Clean the .pdb (etc) files.
		local sufs = .pdb .map .lib .exp .ilk ;
	    local zap = $(_t:S=$(sufs)) ;
	    MakeLocate $(zap) : $(outputPath) ;
	    Clean clean:$(TARGET) : $(zap) ;

	    Depends $(zap) : $(_linkTargets) ;

		if $(COMPILER) in vs2005 vs2008 vs2010  &&  ! ( nomanifest in $(OPTIONS) )
		{
			_writeManifest $(TARGET) : $(_t) : 1 ;
			_linkManifest $(_t) ;
			linkFlags += /MANIFEST /MANIFESTFILE:$(LOCATE_TARGET)/$(_t:G=).intermediate.manifest ;
		}
	}

	LINKFLAGS on $(_linkTargets) = $(linkFlags) ;
	LINKLIBS on $(_linkTargets) = $(linkLibs) ;

	UseCommandLine $(_linkTargets) : $(linkFlags) $(linkLibs) $(needLibs) $(_s) ;

	local linkRule = Link ;

	if $(COMPILER) in vc6 {
		if $(CONFIG) = debug {
			linkRule = LinkDebug ;
		}
	} else if $(COMPILER) in vs2003 vs2005 vs2008 vs2010 {
		if nomanifest in $(OPTIONS) {
			linkRule = LinkNoManifest ;
		} else if $(CONFIG) = debug {
			linkRule = LinkDebug ;
		}
	}

	$(linkRule) $(_linkTargets) : $(_s) ;

#	Includes $(_s) : $(_s) ;

	LINK_TARGET on $(TARGET) = $(_linkTargets) ;
}


########################################################################
########################################################################

rule Library TARGET : SOURCES : OPTIONS
{
	local objects = [ MultiCppCompile $(TARGET) : $(SOURCES) : $(TARGET) ] ;
	if shared in $(OPTIONS)  ||  module in $(OPTIONS)
	{
		SharedLibraryFromObjects $(TARGET) : $(objects) : $(OPTIONS) ;
	}
	else
	{
		LibraryFromObjects $(TARGET) : $(objects) ;
	}
	ACTIVE_PROJECT = ;
}


rule LibraryFromObjects TARGET : OBJECTS
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	local _s = $(OBJECTS:G=$(grist)) ;
	local _l = $(TARGET:G=$(TARGET))$(SUFLIB) ;
	local _lBINDING = [ _retrieveOutputName $(TARGET) : SUFLIB ] ;
	BINDING on $(_l) = $(_lBINDING) ;

	# library depends on its member objects

    Depends all : $(TARGET) ;
	if $(KEEPOBJS)
	{
		Depends $(TARGET) : $(_s) ;
	}
	else
	{
		Depends $(TARGET) : $(_l) ;
	}

	NotFile $(TARGET) ;

	# Set LOCATE for the library and its contents.  The bound
	# value shows up as $(NEEDLIBS) on the Link actions.
	# For compatibility, we only do this if the library doesn't
	# already have a path.

	if ! $(_l:D)
	{
		local outputPath = [ _retrieveOutputPath $(TARGET) ] ;
	    MakeLocate $(_l) $(_l)($(_s:BS)) : $(outputPath) ;
		BINDING on $(_l)($(_s:BS)) = $(_lBINDING) ;
	}

	if $(NOARSCAN)
	{
	    # If we can't scan the library to timestamp its contents,
	    # we have to just make the library depend directly on the
	    # on-disk object files.

	    Depends $(_l) : $(_s) ;
	}
	else
	{
	    # If we can scan the library, we make the library depend
	    # on its members and each member depend on the on-disk
	    # object file.

	    Depends $(_l) : $(_l)($(_s:BS)) ;

		local _i ;
	    for _i in $(_s)
	    {
			Depends $(_l)($(_i:BS)) : $(_i) ;
	    }
	}

	Depends clean : clean:$(TARGET) ;
	NotFile clean:$(TARGET) ;
	Always clean:$(TARGET) ;
	Depends allclean : allclean:$(TARGET) ;
	NotFile allclean:$(TARGET) ;
	Always allclean:$(TARGET) ;
	Depends allclean:$(TARGET) : clean:$(TARGET) ;
	Clean clean:$(TARGET) : $(_l) ;

	if $(CRELIB) { CreLib $(_l) : $(_s[1]) ; }

	local libFlags =
		[ _retrieveVar LIBFLAGS : $(TARGET) : $(CONFIG) : $(PLATFORM) ]
		[ _retrieveVar LIBFLAGS : * : $(CONFIG) : $(PLATFORM) ] ;
	LIBFLAGS on $(_l) = $(libFlags) ;

	UseCommandLine $(_l) : $(libFlags) $(_s) ;

	Archive $(_l) : $(_s) ;

	if $(RANLIB) { Ranlib $(_l) ; }

	# If we can't scan the library, we have to leave the .o's around.

	if ! ( $(NOARSCAN) || $(NOARUPDATE) ) { RmTemps $(_l) : $(_s) ; }
}


rule SharedLibraryFromObjects TARGET : OBJECTS : OPTIONS
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	local _s = $(OBJECTS:G=$(grist)) ;

	local suffixName = SUFSHAREDLIB ;
	if module in $(OPTIONS) {
		suffixName = SUFMODULE ;
	}

	local _t = [ _retrieveOutputName $(TARGET) : $(suffixName) ] ;
	_t = $(_t:G=$(grist)) ;

	local outputPath = [ _retrieveOutputPath $(TARGET) ] ;

	local _linkTargets = $(_t) ;

	if ! ( noexportlib in $(OPTIONS) ) {
		local _tlib = @($(TARGET)$(SUFLIB):G=$(grist)) ;

		if $(COMPILER) in vc6 vs2003 vs2005 vs2008 vs2010 {
			BINDING on $(_tlib) = [ _retrieveOutputName $(TARGET) : SUFLIB ] ;
			Depends $(TARGET) : $(_tlib) ;
			Depends $(_tlib) : $(_t) ;
			MightNotUpdate $(_tlib) ;
			_linkTargets += $(_tlib) ;
		}
		else if $(COMPILER) in mingw gcc {
#			BINDING on $(_tlib) = [ _retrieveOutputName $(TARGET) : SUFLIB ] ;
			BINDING on $(_tlib) = $(_t) ;
			MakeLocate $(_tlib) : $(outputPath) ;
			Depends $(TARGET) : $(_tlib) ;
			Depends $(_tlib) : $(_t) ;
			NotFile $(_tlib) ;		# Turn this off for export libraries.
			_linkTargets += $(_tlib) ;

#			LinkFlags $(TARGET) : -Wl,--out-implib,$(_tlib:T) ;
		}
#		else if $(UNIX)
#		{
#			Exit SharedLibraryFromObjects not implemented. ;
#		}
	}
	else
	{
		Depends $(TARGET) : $(_t) ;
	}

	Depends all : $(TARGET) ;
#	Depends $(TARGET) : $(_linkTargets) ;
	NotFile $(TARGET) ;
#	Depends $(_linkTargets) : $(_s) ;
	Depends $(_t) : $(_s) ;
	MakeLocate $(_linkTargets) : $(outputPath) ;

	local regserver ;
	if regserver in $(OPTIONS)  &&  $(COMPILER) in vc6 vs2003 vs2005 vs2008 vs2010 {
		regserver = true ;

		local unregserver = clean:$(TARGET):unregserver ;
		Depends clean:$(TARGET) : $(unregserver) ;
		NotFile $(unregserver) ;
		Always $(unregserver) ;
		UnRegSvr32 clean:$(TARGET):unregserver : $(_linkTargets[1]) ;
	}

	Depends clean : clean:$(TARGET) ;
	NotFile clean:$(TARGET) ;
	Always clean:$(TARGET) ;
	Depends allclean : allclean:$(TARGET) ;
	NotFile allclean:$(TARGET) ;
	Always allclean:$(TARGET) ;
	Depends allclean:$(TARGET) : clean:$(TARGET) ;
	Clean clean:$(TARGET) : $(_linkTargets) ;

	local linkFlags =
		[ FLibraryPaths [ _retrieveVar LINKDIRECTORIES : $(TARGET) : $(CONFIG) : $(PLATFORM) ] ]
		[ FLibraryPaths [ _retrieveVar LINKDIRECTORIES : * : $(CONFIG) : $(PLATFORM) ] ]
		[ _retrieveVar LINKFLAGS : $(TARGET) : $(CONFIG) : $(PLATFORM) ]
		[ _retrieveVar LINKFLAGS : * : $(CONFIG) : $(PLATFORM) ] ;

	if $(COMPILER) in vc6 vs2003 vs2005 vs2008 vs2010 {
		if ! ( nodefaults in $(OPTIONS) ) {
			if windows in $(OPTIONS) {
				linkFlags += /SUBSYSTEM:WINDOWS ;
			} else {
				linkFlags += /SUBSYSTEM:CONSOLE ;
			}
		}
		linkFlags += /DLL ;
	} else if $(COMPILER) = mingw {
		linkFlags += -shared ;
	} else if $(COMPILER) = gcc  &&  $(OS) = MACOSX {
		if module in $(OPTIONS) {
			linkFlags += -bundle -undefined dynamic_lookup ;
		} else {
			local installName =
				[ _retrieveVar INSTALL_NAME_PATH : $(TARGET) : $(CONFIG) : $(PLATFORM) ]
				[ _retrieveVar INSTALL_NAME_PATH : * : $(CONFIG) : $(PLATFORM) ] ;
			if ! $(installName)
			{
				installName = $(_t:TD) ;
			}
			else
			{
				installName = $(installName[1]) ;
			}
			installName = $(_t:BSR=$(installName)) ;
			on $(TARGET) linkFlags += -dynamiclib -install_name $(installName) ;
		}
	}
#	else if $(UNIX)
#	{
#		Exit SharedLibraryFromObjects not implemented. ;
#	}

	local linkLibs =
		[ _retrieveVar LINKLIBS : $(TARGET) : $(CONFIG) : $(PLATFORM) ]
		[ _retrieveVar LINKLIBS : * : $(CONFIG) : $(PLATFORM) ] ;

	local needLibs =
		[ _retrieveVar NEEDLIBS : $(TARGET) : $(CONFIG) : $(PLATFORM) ]
		[ _retrieveVar NEEDLIBS : * : $(CONFIG) : $(PLATFORM) ] ;

	NEEDLIBS on $(_linkTargets) = $(needLibs:S=$(SUFLIB)) ;
	Depends $(_t) : $(needLibs) ;

	if $(MSVCNT) {
	    # Clean the .pdb (etc) files.
		local sufs = .pdb .map .exp .ilk ;
	    local zap = $(_t:S=$(sufs)) ;
	    MakeLocate $(zap) : $(outputPath) ;
	    Clean clean:$(TARGET) : $(zap) ;

	    Depends $(zap) : $(_linkTargets) ;

		if ( nomanifest in $(OPTIONS) ) {
			linkFlags -= /INCREMENTAL ;
		} else if $(COMPILER) in vs2005 vs2008 vs2010  &&  ! ( nomanifest in $(OPTIONS) ) {
			_writeManifest $(TARGET) : $(_linkTargets) : 2 ;
			_linkManifest $(_linkTargets) ;
			linkFlags += /MANIFEST /MANIFESTFILE:$(LOCATE_TARGET)/$(_t:G=).intermediate.manifest ;
		}
	}

	LINKFLAGS on $(_linkTargets) = $(linkFlags) ;
	LINKLIBS on $(_linkTargets) = $(linkLibs) ;

	UseCommandLine $(_linkTargets) : $(linkFlags) $(linkLibs) $(needLibs) $(_s) ;

	local linkRule = Link ;

	if $(COMPILER) in vc6 {
		if $(CONFIG) = debug {
			linkRule = LinkDebug ;
		}
	} else if $(COMPILER) in vs2003 vs2005 vs2008 vs2010 {
		if nomanifest in $(OPTIONS) {
			linkRule = LinkNoManifest ;
		} else if $(CONFIG) = debug {
			linkRule = LinkDebug ;
		}
	}

	$(linkRule) $(_linkTargets) : $(_s) ;
#	Includes $(_s) : $(_s) ;

	if $(regserver) {
		RegSvr32 $(_linkTargets[1]) ;
	}

	LINK_TARGET on $(TARGET) = $(_linkTargets) ;
}


########################################################################
########################################################################

rule CreatePrecompiledHeader TARGET : NAME : HEADER
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	HEADER ?= $(NAME[1]:S=.h) ;
	local SOURCE = $(NAME[1]) ;
	if ! $(SOURCE:S)
	{
		SOURCE = $(SOURCE:S=.cpp) ;
	}
	local cppPchFilename = $(SOURCE:G=$(grist)) ;
	PCH on $(cppPchFilename) = $(SOURCE) $(HEADER) 1 ;
}


rule UsePrecompiledHeader TARGET : NAME : HEADER : FILES
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	local SOURCE = $(NAME[1]) ;
	if ! $(SOURCE:S)
	{
		SOURCE = $(SOURCE:S=.cpp) ;
	}
	local cppPchFilename = $(SOURCE:G=$(grist)) ;
	local file ;
	for file in $(FILES:G=$(grist))
	{
		if $(file:S) in .cpp .c  &&  $(file) != $(cppPchFilename)
		{
			PCH on $(file) = $(SOURCE) $(HEADER) ;
		}
	}
}


rule PrecompiledHeader TARGET : NAME : FILES
{
	if ! $(NAME[1]:S)
	{
		NAME[1] = $(NAME[1]:S=.cpp) ;
	}
	local header = $(NAME[2]:E=$(NAME[1]:S=.h)) ;
	CreatePrecompiledHeader $(TARGET) : $(NAME[1]) $(NAME[1]:S) : $(header) $(NAME[3]:E=$(header)) ;
	UsePrecompiledHeader $(TARGET) : $(NAME[1]) $(NAME[1]:S) : $(header) $(NAME[3]:E=$(header)) : $(FILES) ;
}


rule NoPrecompiledHeader TARGET : FILES
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	NOPCH on $(FILES:G=$(grist)) = 1 ;
}


########################################################################
########################################################################

# Originally from http://maillist.perforce.com/pipermail/jamming/2004-July.txt.gz
# windows resource compiler.
rule ResourceCompiler PARENT : SOURCES : OPTIONS
{
	PARENT = [ _retrieveActiveTargetName $(PARENT) ] ;
	local grist = $(PARENT) ;

	SOURCES = $(SOURCES:G=$(grist)) ;
	local TARGETS = $(SOURCES:S=.res) ;

	SearchSource $(SOURCES) ;
	MakeLocate $(TARGETS) : $(LOCATE_TARGET) ;

	Depends $(TARGETS) : $(SOURCES) ;
	Clean clean:$(PARENT) : $(TARGETS) ;

	RCDEFINES on $(TARGETS) +=
		[ on $(PARENT) Var RCDEFINES ]
		[ on * Var RCDEFINES ]
	;

	RCFLAGS on $(TARGETS) +=
		[ on $(PARENT) Var RCFLAGS ]
		[ on * Var RCFLAGS ]
	;

	RCHDRS on $(TARGETS) +=
		$(SEARCH_SOURCE)
		[ on $(PARENT) Var RCHDRS ]
		[ on * Var RCHDRS ]
		$(SUBDIRHDRS)
		$(STDHDRS)
	;

	UseCommandLine $(TARGETS) :
			[ on $(TARGETS) Var RCDEFINES ]
			[ on $(TARGETS) Var RCFLAGS ]
			[ on $(TARGETS) Var RCHDRS ]
	;

	if quiet in $(OPTIONS)
	{
		ResourceCompileQuiet $(TARGETS) : $(SOURCES) ;
	}
	else
	{
		ResourceCompile $(TARGETS) : $(SOURCES) ;
	}

	return $(TARGETS) ;
}

actions ResourceCompile
{
	SET INCLUDE=$(RCHDRS:\\J=;)
	"$(RC:\\)" /fo $(1) $(RCFLAGS) /d$(RCDEFINES) $(2)
}

actions quietly ResourceCompileQuiet
{
	SET INCLUDE=$(RCHDRS:\\J=;)
	"$(RC:\\)" /fo $(1) $(RCFLAGS) /d$(DEFINES) $(2)
}

# Set resource compiler options
rule _RcOptions TARGET : VARIABLE : RESOURCE_NAME : OPTIONS
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;

	local target ;
	if $(OPTIONS)
	{
		target = $(RESOURCE_NAME:S=.res:G=$(grist)) ;
	}
	else
	{
		OPTIONS = $(RESOURCE_NAME) ;
		target = $(TARGET) ;
	}

	$(VARIABLE) on $(target) += $(OPTIONS) ;
}


rule RcFlags TARGET : RESOURCE_NAME : FLAGS
{
	_RcOptions $(TARGET) : RCFLAGS : $(RESOURCE_NAME) : $(FLAGS) ;
}

rule RcDefines TARGET : RESOURCE_NAME : DEFINES
{
	_RcOptions $(TARGET) : RCDEFINES : $(RESOURCE_NAME) : $(DEFINES) ;
}

rule RcIncludeDirectories TARGET : RESOURCE_NAME : HDRS
{
	_RcOptions $(TARGET) : RCHDRS : $(RESOURCE_NAME) : $(HDRS) ;
}


########################################################################
########################################################################

ACTIVE_PROJECT = "" ;

rule ActiveProject PROJECT
{
	ACTIVE_PROJECT = $(PROJECT) ;
}


rule CFlags TARGET : FLAGS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	CCFLAGS.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(FLAGS) ;
}


rule C++Flags TARGET : FLAGS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	C++FLAGS.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(FLAGS) ;
}


rule AddFlags TARGET : FLAGS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	FLAGS_TO_ADD.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(FLAGS) ;
	FLAGS_TO_REMOVE.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) -= $(FLAGS) ;
}


rule RemoveFlags TARGET : FLAGS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	FLAGS_TO_ADD.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) -= $(FLAGS) ;
	FLAGS_TO_REMOVE.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(FLAGS) ;
}


rule CRuntimeType TARGET : TYPE : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_PLATFORM ?= $(PLATFORM) ;
	if $(COMPILER) in vc6 vs2003 vs2005 vs2008 vs2010
	{
		if ! $(TYPE)  ||  $(TYPE) = dynamic
		{
			FLAGS_TO_REMOVE.$(THE_PLATFORM).debug on $(TARGET) -= /MDd ;
			FLAGS_TO_REMOVE.$(THE_PLATFORM).release on $(TARGET) -= /MD ;
			FLAGS_TO_REMOVE.$(THE_PLATFORM).releaseltcg on $(TARGET) -= /MD ;
			FLAGS_TO_REMOVE.$(THE_PLATFORM).debug on $(TARGET) += /MTd ;
			FLAGS_TO_REMOVE.$(THE_PLATFORM).release on $(TARGET) += /MT ;
			FLAGS_TO_REMOVE.$(THE_PLATFORM).releaseltcg on $(TARGET) += /MT ;

			FLAGS_TO_ADD.$(THE_PLATFORM).debug on $(TARGET) += /MDd ;
			FLAGS_TO_ADD.$(THE_PLATFORM).release on $(TARGET) += /MD ;
			FLAGS_TO_ADD.$(THE_PLATFORM).releaseltcg on $(TARGET) += /MD ;
		}
		else if $(TYPE) = static
		{
			FLAGS_TO_REMOVE.$(THE_PLATFORM).debug on $(TARGET) -= /MTd ;
			FLAGS_TO_REMOVE.$(THE_PLATFORM).release on $(TARGET) -= /MT ;
			FLAGS_TO_REMOVE.$(THE_PLATFORM).releaseltcg on $(TARGET) -= /MT ;
			FLAGS_TO_REMOVE.$(THE_PLATFORM).debug on $(TARGET) += /MDd ;
			FLAGS_TO_REMOVE.$(THE_PLATFORM).release on $(TARGET) += /MD ;
			FLAGS_TO_REMOVE.$(THE_PLATFORM).releaseltcg on $(TARGET) += /MD ;

			FLAGS_TO_ADD.$(THE_PLATFORM).debug on $(TARGET) += /MTd ;
			FLAGS_TO_ADD.$(THE_PLATFORM).release on $(TARGET) += /MT ;
			FLAGS_TO_ADD.$(THE_PLATFORM).releaseltcg on $(TARGET) += /MT ;
		}
	}
}


rule Defines TARGET : DEFINES : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	DEFINES.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(DEFINES) ;
}


rule DefFile TARGET : SOURCES
{
	if $(COMPILER) in vc6 vs2002 vs2003 vs2005 vs2008 vs2010
	{
		TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
		local grist = $(TARGET) ;
		SOURCES = $(SOURCES:G=$(grist)) ;
		SEARCH on $(SOURCES) = $(SEARCH_SOURCE) ;
		Depends $(TARGET) : $(SOURCES) ;
		LinkFlags $(TARGET) : /DEF:"$(SOURCES:T)" ;
	}
}


rule ExcludeFromBuild TARGET : SOURCES
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	EXCLUDED_FROM_BUILD on $(SOURCES:G=$(grist)) = true ;
}


rule ForceInclude TARGET : INCLUDES : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	if $(COMPILER) in vc6 vs2002 vs2003 vs2005 vs2008 vs2010 {
		AddFlags $(TARGET) : "/FI$(INCLUDES:R=$(SUBDIR:E=""))" : $(THE_CONFIG) : $(THE_PLATFORM) ;
	} else {
		AddFlags $(TARGET) : "-include $(INCLUDES:R=$(SUBDIR:E=""))" : $(THE_CONFIG) : $(THE_PLATFORM) ;
	}
}


rule IncludeDirectories TARGET : INCLUDEPATHS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	HDRS.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(INCLUDEPATHS:R=$(SUBDIR:E="")) ;
}


rule InstallNamePath TARGET : INSTALL_NAME_PATH : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	INSTALL_NAME_PATH.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(INSTALL_NAME_PATH) ;
}


rule LinkDirectories TARGET : DIRECTORIES : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	LINKDIRECTORIES.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(DIRECTORIES:R=$(SUBDIR:E="")) ;
}


rule LinkFlags TARGET : FLAGS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	LINKFLAGS.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(FLAGS) ;
}


rule LinkFrameworks TARGET : FRAMEWORKS : THE_CONFIG : THE_PLATFORM
{
	if $(PLATFORM) in macosx iphone iphonesimulator {
		LinkFlags $(TARGET) : "-framework $(FRAMEWORKS)" : $(THE_CONFIG) : $(THE_PLATFORM) ;
	}
}


rule LinkLibraries TARGET : LIBRARIES : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	Depends $(TARGET) : $(LIBRARIES) ;
	Depends allclean:$(TARGET) : allclean:$(LIBRARIES) ;
	NotFile allclean:$(TARGET) ;
	Always allclean:$(TARGET) ;

	local gristLibraries ;
	local lib ;
	for lib in $(LIBRARIES)
	{
		gristLibraries += $(lib:G=$(lib))$(SUFLIB) ;
	}
	NEEDLIBS.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(gristLibraries) ;
}


rule LinkPrebuiltLibraries TARGET : LIBRARIES : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	local newLibraries ;
	local lib ;
	for lib in $(LIBRARIES) {
		if $(lib:S) {
			newLibraries += $(lib) ;
		} else {
			newLibraries += $(lib)$(SUFLIB) ;
		}
	}
	LINKLIBS.$(THE_PLATFORM).$(THE_CONFIG) on $(TARGET) += $(newLibraries) ;
}


rule NoWorkspace WORKSPACE_NAME
{
}


rule ObjectCFlags TARGET : SOURCES : FLAGS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	local sources = $(SOURCES:I=\\.c$) ;
	local objTargets = $(sources:S=$(SUFOBJ):G=$(grist)) ;
	CCFLAGS.$(THE_PLATFORM).$(THE_CONFIG) on $(objTargets) += $(FLAGS) ;
}


rule ObjectC++Flags TARGET : SOURCES : FLAGS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	local sources = $(SOURCES:I=\\.cpp$) ;
	local objTargets = $(sources:S=$(SUFOBJ):G=$(grist)) ;
	C++FLAGS.$(THE_PLATFORM).$(THE_CONFIG) on $(objTargets) += $(FLAGS) ;
}


rule ObjectDefines TARGET : SOURCES : DEFINES : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	local objTargets = $(SOURCES:S=$(SUFOBJ):G=$(grist)) ;
	DEFINES.$(THE_PLATFORM).$(THE_CONFIG) on $(objTargets) += $(DEFINES) ;
}


rule ObjectForceInclude TARGET : SOURCES : INCLUDES : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	local objTargets = $(SOURCES:S=$(SUFOBJ):G=$(grist)) ;
	local variableFlags = CCFLAGS C++FLAGS ;
	if $(COMPILER) in vc6 vs2002 vs2003 vs2005 vs2008 vs2010 {
		$(variableFlags).$(THE_PLATFORM).$(THE_CONFIG) on $(objTargets) += "/FI$(INCLUDES:R=$(SUBDIR:E=""))" ;
	} else {
		$(variableFlags).$(THE_PLATFORM).$(THE_CONFIG) on $(objTargets) += "-include $(INCLUDES:R=$(SUBDIR:E=""))" ;
	}
}


rule ObjectIncludeDirectories TARGET : SOURCES : INCLUDEPATHS : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local grist = $(TARGET) ;
	THE_CONFIG ?= * ;
	THE_PLATFORM ?= * ;
	local objTargets = $(SOURCES:S=$(SUFOBJ):G=$(grist)) ;
	HDRS.$(THE_PLATFORM).$(THE_CONFIG) on $(objTargets) += $(INCLUDEPATHS:R=$(SUBDIR:E="")) ;
}


rule OutputName TARGET : NAME : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	OUTPUTNAME.$(THE_PLATFORM:E=*).$(THE_CONFIG:E=*) on $(TARGET) = $(NAME) ;
}


rule OutputPath TARGET : OUTPUTPATH : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	LOCATE.$(THE_PLATFORM:E=*).$(THE_CONFIG:E=*) on $(TARGET) = $(OUTPUTPATH:R=$(SUBDIR:E="")) ;
}


rule OutputPostfix TARGET : POSTFIX : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	OUTPUTPOSTFIX.$(THE_PLATFORM:E=*).$(THE_CONFIG:E=*) on $(TARGET) = $(POSTFIX:E=*off*) ;
}


rule OutputPostfixClear TARGET : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	OUTPUTPOSTFIX.$(THE_PLATFORM:E=*).$(THE_CONFIG:E=*) on $(TARGET) = ;
}


rule OutputSuffix TARGET : SUFFIX : THE_CONFIG : THE_PLATFORM
{
	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local NO_DOT_SUFFIX = [ Match \\.?(.+) : $(SUFFIX) ] ;
	SUFFIX = .$(NO_DOT_SUFFIX) ;
	OUTPUTSUFFIX.$(THE_PLATFORM:E=*).$(THE_CONFIG:E=*) on $(TARGET) = $(SUFFIX) ;
}


rule Project PROJECT_NAME : SOURCES
{
}


rule ProjectGroup TARGET : FOLDERNAME : PROJECTS
{
}


rule SearchSource SOURCES : SEARCH_PATH
{
	SEARCH on $(SOURCES) ?= $(SEARCH_PATH:E=$(SEARCH_SOURCE)) ;
}


rule SourceGroup TARGET : FOLDERNAME : SOURCES
{
}


rule Workspace WORKSPACE_NAME : TARGETS
{
}


rule MacOSX_SDK TARGET : SDK_PLATFORM : SDK_VERSION {
	if $(PLATFORM) != macosx { return ; }

	TARGET = [ _retrieveActiveTargetName $(TARGET) ] ;
	local developerRoot ;
	local isysroot ;
	switch $(SDK_PLATFORM) {
		case macosx :
			developerRoot = /Developer/SDKs ;
			SDK_VERSION ?= 10.5 ;
			switch $(SDK_VERSION) {
				case 10.4u :	isysroot = $(developerRoot)/MacOSX10.4u.sdk ;
				case 10.5 :		isysroot = $(developerRoot)/MacOSX10.5.sdk ;
				case * :		Exit "* MacOSX_SDK: Unsupported version $(SDK_VERSION) for SDK platform $(SDK_PLATFORM)." ;
			}
			developerRoot = $(isysroot) ;

		case iphone :
			developerRoot = /Developer/Platforms/iPhoneOS.platform/Developer ;
			SDK_VERSION ?= 2.2 ;
			switch $(SDK_VERSION) {
				case 2.0 :	isysroot = $(developerRoot)/SDKs/iPhoneOS2.0.sdk ;
				case 2.1 :	isysroot = $(developerRoot)/SDKs/iPhoneOS2.1.sdk ;
				case 2.2 :	isysroot = $(developerRoot)/SDKs/iPhoneOS2.2.sdk ;
				case 3.0 :	isysroot = $(developerRoot)/SDKs/iPhoneOS3.0.sdk ;
				case * :	Exit "* MacOSX_SDK: Unsupported version $(SDK_VERSION) for SDK platform $(SDK_PLATFORM)." ;
			}

		case iphonesimulator :
			developerRoot = /Developer/Platforms/iPhoneSimulator.platform/Developer ;
			SDK_VERSION ?= 2.2 ;
			switch $(SDK_VERSION) {
				case 2.0 :	isysroot = $(developerRoot)/SDKs/iPhoneSimulator2.0.sdk ;
				case 2.1 :	isysroot = $(developerRoot)/SDKs/iPhoneSimulator2.1.sdk ;
				case 2.2 :	isysroot = $(developerRoot)/SDKs/iPhoneSimulator2.2.sdk ;
				case 3.0 :	isysroot = $(developerRoot)/SDKs/iPhoneSimulator3.0.sdk ;
				case * :	Exit "* MacOSX_SDK: Unsupported version $(SDK_VERSION) for SDK platform $(SDK_PLATFORM)." ;
			}
	}

	CCFLAGS.*.* on $(TARGET) = -isysroot $(isysroot) ;
	C++FLAGS.*.* on $(TARGET) = -isysroot $(isysroot) ;
	MFLAGS.*.* on $(TARGET) = -isysroot $(isysroot) ;
	MMFLAGS.*.* on $(TARGET) = -isysroot $(isysroot) ;
	LINKFLAGS.*.* on $(TARGET) = -isysroot $(isysroot) ;
	MACOSX_SDK_DEVELOPER_ROOT on $(TARGET) = $(developerRoot) ;
}


#
# Now include the user's Jamfile.
#

include $(JAMFILE) ;
